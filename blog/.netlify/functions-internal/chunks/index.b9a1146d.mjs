import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
/* empty css                           */import 'axios';
/* empty css                          *//* empty css                           *//* empty css                          *//* empty css                              *//* empty css                              */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           *//* empty css                              */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "before-you-start", "text": "Before You Start" }, { "depth": 2, "slug": "dependency-and-file-setup", "text": "Dependency and File Setup" }, { "depth": 2, "slug": "define-parameters", "text": "Define Parameters" }, { "depth": 2, "slug": "fetch-episodes-with-feedparser", "text": "Fetch Episodes with Feedparser" }, { "depth": 3, "slug": "filter-episodes-within-date-range", "text": "Filter Episodes Within Date Range" }, { "depth": 2, "slug": "transcribe-episodes-with-keyword-boosting-and-search", "text": "Transcribe Episodes with Keyword Boosting and Search" }, { "depth": 3, "slug": "filter-only-high-confidence-results", "text": "Filter Only High Confidence Results" }, { "depth": 2, "slug": "save-mentions-report", "text": "Save Mentions Report" }, { "depth": 2, "slug": "extending-this-project", "text": "Extending This Project" }], "source": "\nIn this post, we'll cover how to check podcast episodes for mentions of your brand. This can be particularly useful for ensuring sponsorship obligations are met, or to check when competitors are spoken about.\n\nGiven an input of a podcast feed URL, start/end dates, and a brand name, the script will generate a report of all mentions as detected by Deepgram's fast and accurate speech recognition API.\n\n## Before You Start\n\nYou must have Python installed on your machine - I'm using Python 3.10 at the time of writing. You will also need a Deepgram API Key - [get one here](https://console.deepgram.com/signup?jump=keys).\n\nCreate a new directory and navigate to it in your terminal. [Create a virtual environment](https://developers.deepgram.com/blog/2022/02/python-virtual-environments/) with `python3 -m venv virtual_env` and activate it with `source virtual_env/bin/activate`. Install dependencies with `pip install deepgram_sdk asyncio python-dotenv feedparser`.\n\nOpen the directory in a code editor, and create an empty `.env` file. Take your Deepgram API Key, and add the following line to `.env`:\n\n    DEEPGRAM_API_KEY=\"replace-this-bit-with-your-key\"\n\n## Dependency and File Setup\n\nCreate an empty `script.py` file and import the dependencies:\n\n```py\nimport os\nimport json\nfrom datetime import datetime\nfrom time import mktime\nimport asyncio\nfrom dotenv import load_dotenv\nfrom deepgram import Deepgram\nimport feedparser\n```\n\nLoad values from the `.env` file and initialize the Deepgram Python SDK:\n\n```py\nload_dotenv()\ndeepgram = Deepgram(os.getenv('DEEPGRAM_API_KEY'))\n```\n\nFinally, set up a `main()` function that is executed automatically when the script is run:\n\n```py\nasync def main():\n    print('Hello world')\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n## Define Parameters\n\nAbove the `main()` function, create a set of variables with settings for your report:\n\n```py\npodcast_feed = 'http://feeds.codenewbie.org/cnpodcast.xml' # CodeNewbie Podcast\nbrand_name = 'stellar'\nrequired_confidence = 0.9\nstart_date = '2022-05-01' # Start of season 20\nend_date = '2022-06-27' # End of season 20\n```\n\nEach time Deepgram returns a search result, it will come with a confidence between 0 and 1. The `required_confidence` value will only report results above the specified confidence level.\n\n## Fetch Episodes with Feedparser\n\nRemove the `print()` statement in the `main()` function, fetch the podcast, and take a look at the returned data by pretty-printing it:\n\n```py\nasync def main():\n    rss = feedparser.parse(podcast_feed)\n    print(json.dumps(rss.entries, indent=2))\n```\n\nTry it out! In your terminal, run the file with `python3 script.py` and you should see a bunch of data for each episode.\n\n### Filter Episodes Within Date Range\n\nFeedparser will take in many different date formats for when a RSS entry is published/updated and normalize them to a standard format. Using the standardized output, create a helper function just below the `main()` function:\n\n```py\ndef check_if_in_date_range(episode):\n    date_with_time = datetime.fromtimestamp(mktime(episode.published_parsed))\n    date = date_with_time.replace(hour=0, minute=0, second=0)\n    is_not_before_start = date >= datetime.fromisoformat(start_date)\n    is_not_after_end = date <= datetime.fromisoformat(end_date)\n    return is_not_before_start and is_not_after_end\n```\n\nThis function takes in an episode, gets the date (without time), and returns `True` if it is within the range between and including `start_date` and `end_date`.\n\nRemove `print(json.dumps(rss.entries, indent=2))` and replace it with the following:\n\n```py\nepisodes = list(filter(check_if_in_date_range, rss.entries))\n```\n\nThe `episodes` array now contains only episodes within the date range.\n\n## Transcribe Episodes with Keyword Boosting and Search\n\nInside of the `main()` function, extract the podcast media URL, set transcription options, and request a Deepgram transcription. Finally, extract search results from the result:\n\n```py\nfor episode in episodes:\n    # Get podcast episode URL\n    source = { 'url': episode.enclosures[0].href }\n    # Increase chance of hearing brand_name\n    # Return search results for brand_name\n    transcription_options = { 'keywords': f'{brand_name}:2', 'search': brand_name }\n    # Request transcription\n    response = await deepgram.transcription.prerecorded(source, transcription_options)\n    # Extract search results\n    search_results = response['results']['channels'][0]['search'][0]['hits']\n```\n\n### Filter Only High Confidence Results\n\nAdd the following line below `search_results` to filter out any values which are below the required confidence:\n\n```py\nstrong_results = list(filter(lambda x: x['confidence'] > required_confidence, search_results))\n```\n\n## Save Mentions Report\n\nBelow `strong_results`, take each episode (and each result within the episode), and add it as a new line in a report file:\n\n```py\n# Define file name\nfilename = f'{brand_name}-mentions-{start_date}-to-{end_date}.txt'\nwith open(filename, 'a+') as f:\n    # Format publish date\n    pub = datetime.fromtimestamp(mktime(episode.published_parsed))\n    # Create line per episode\n    f.write(f'{pub}: \"{episode.title}\" ({len(strong_results)} mentions)\\n')\n    # Create line per result (indented two spaces)\n    for result in strong_results:\n        f.write(f'  Mention at {result[\"start\"]}s of \\\"{result[\"snippet\"]}\\\"\\n')\n```\n\nThat's it! Rerun the script with `python3 script.py` and, once completed, you should see a new file called `stellar-mentions-2022-05-01-to-2022-06-27.txt` - perfect if you want to run several reports.\n\n## Extending This Project\n\nThis project should equip you with the information you need to understand if and how often brand mentions occur throughout several podcast episodes. You should extend this further by creating more complex or graphical reports, allowing several brands to be searched for in one request, or by building a UI around this logic.\n\nAs ever, if you have any questions please feel free to get in touch or post in our [community discussions](https://github.com/orgs/deepgram/discussions).\n\nThe final code is as follows:\n\n```py\nimport asyncio\nimport os\nfrom datetime import datetime\nfrom time import mktime\nfrom dotenv import load_dotenv\nfrom deepgram import Deepgram\nimport feedparser\n\nload_dotenv()\ndeepgram = Deepgram(os.getenv('DEEPGRAM_API_KEY'))\n\npodcast_feed = 'http://feeds.codenewbie.org/cnpodcast.xml'\nbrand_name = 'stellar'\nrequired_confidence = 0.9\nstart_date = '2022-05-01'\nend_date = '2022-06-27'\n\nasync def main():\n    rss = feedparser.parse(podcast_feed)\n    episodes = list(filter(check_if_in_date_range, rss.entries))\n    print(len(episodes))\n\n    for episode in episodes:\n        source = { 'url': episode.enclosures[0].href }\n        transcription_options = { 'keywords': f'{brand_name}:2', 'search': brand_name }\n        response = await deepgram.transcription.prerecorded(source, transcription_options)\n        search_results = response['results']['channels'][0]['search'][0]['hits']\n        strong_results = list(filter(lambda x: x['confidence'] > required_confidence, search_results))\n\n        filename = f'{brand_name}-mentions-{start_date}-to-{end_date}.txt'\n        with open(filename, 'a+') as f:\n            pub = datetime.fromtimestamp(mktime(episode.published_parsed))\n            f.write(f'{pub}: \"{episode.title}\" ({len(strong_results)} mentions)\\n')\n            for result in strong_results:\n                f.write(f'  Mention at {result[\"start\"]}s of \\\"{result[\"snippet\"]}\\\"\\n')\n\ndef check_if_in_date_range(episode):\n    date_with_time = datetime.fromtimestamp(mktime(episode.published_parsed))\n    date = date_with_time.replace(hour=0, minute=0, second=0)\n    is_not_before_start = date >= datetime.fromisoformat(start_date)\n    is_not_after_end = date <= datetime.fromisoformat(end_date)\n    return is_not_before_start and is_not_after_end\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n", "html": '<p>In this post, we\u2019ll cover how to check podcast episodes for mentions of your brand. This can be particularly useful for ensuring sponsorship obligations are met, or to check when competitors are spoken about.</p>\n<p>Given an input of a podcast feed URL, start/end dates, and a brand name, the script will generate a report of all mentions as detected by Deepgram\u2019s fast and accurate speech recognition API.</p>\n<h2 id="before-you-start">Before You Start</h2>\n<p>You must have Python installed on your machine - I\u2019m using Python 3.10 at the time of writing. You will also need a Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get one here</a>.</p>\n<p>Create a new directory and navigate to it in your terminal. <a href="https://developers.deepgram.com/blog/2022/02/python-virtual-environments/">Create a virtual environment</a> with <code is:raw>python3 -m venv virtual_env</code> and activate it with <code is:raw>source virtual_env/bin/activate</code>. Install dependencies with <code is:raw>pip install deepgram_sdk asyncio python-dotenv feedparser</code>.</p>\n<p>Open the directory in a code editor, and create an empty <code is:raw>.env</code> file. Take your Deepgram API Key, and add the following line to <code is:raw>.env</code>:</p>\n<p>DEEPGRAM_API_KEY=\u201Creplace-this-bit-with-your-key\u201D</p>\n<h2 id="dependency-and-file-setup">Dependency and File Setup</h2>\n<p>Create an empty <code is:raw>script.py</code> file and import the dependencies:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> os</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> datetime </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> datetime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> time </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> mktime</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> dotenv </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> load_dotenv</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> deepgram </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> Deepgram</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> feedparser</span></span></code></pre>\n<p>Load values from the <code is:raw>.env</code> file and initialize the Deepgram Python SDK:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">load_dotenv()</span></span>\n<span class="line"><span style="color: #C9D1D9">deepgram </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> Deepgram(os.getenv(</span><span style="color: #A5D6FF">&#39;DEEPGRAM_API_KEY&#39;</span><span style="color: #C9D1D9">))</span></span></code></pre>\n<p>Finally, set up a <code is:raw>main()</code> function that is executed automatically when the script is run:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Hello world&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    asyncio.run(main())</span></span></code></pre>\n<h2 id="define-parameters">Define Parameters</h2>\n<p>Above the <code is:raw>main()</code> function, create a set of variables with settings for your report:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">podcast_feed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;http://feeds.codenewbie.org/cnpodcast.xml&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># CodeNewbie Podcast</span></span>\n<span class="line"><span style="color: #C9D1D9">brand_name </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stellar&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">required_confidence </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.9</span></span>\n<span class="line"><span style="color: #C9D1D9">start_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-05-01&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># Start of season 20</span></span>\n<span class="line"><span style="color: #C9D1D9">end_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-06-27&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># End of season 20</span></span></code></pre>\n<p>Each time Deepgram returns a search result, it will come with a confidence between 0 and 1. The <code is:raw>required_confidence</code> value will only report results above the specified confidence level.</p>\n<h2 id="fetch-episodes-with-feedparser">Fetch Episodes with Feedparser</h2>\n<p>Remove the <code is:raw>print()</code> statement in the <code is:raw>main()</code> function, fetch the podcast, and take a look at the returned data by pretty-printing it:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    rss </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> feedparser.parse(podcast_feed)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(json.dumps(rss.entries, </span><span style="color: #FFA657">indent</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">))</span></span></code></pre>\n<p>Try it out! In your terminal, run the file with <code is:raw>python3 script.py</code> and you should see a bunch of data for each episode.</p>\n<h3 id="filter-episodes-within-date-range">Filter Episodes Within Date Range</h3>\n<p>Feedparser will take in many different date formats for when a RSS entry is published/updated and normalize them to a standard format. Using the standardized output, create a helper function just below the <code is:raw>main()</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">check_if_in_date_range</span><span style="color: #C9D1D9">(episode):</span></span>\n<span class="line"><span style="color: #C9D1D9">    date_with_time </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date_with_time.replace(</span><span style="color: #FFA657">hour</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">minute</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">second</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_before_start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(start_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_after_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&lt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(end_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> is_not_before_start </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> is_not_after_end</span></span></code></pre>\n<p>This function takes in an episode, gets the date (without time), and returns <code is:raw>True</code> if it is within the range between and including <code is:raw>start_date</code> and <code is:raw>end_date</code>.</p>\n<p>Remove <code is:raw>print(json.dumps(rss.entries, indent=2))</code> and replace it with the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">episodes </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(check_if_in_date_range, rss.entries))</span></span></code></pre>\n<p>The <code is:raw>episodes</code> array now contains only episodes within the date range.</p>\n<h2 id="transcribe-episodes-with-keyword-boosting-and-search">Transcribe Episodes with Keyword Boosting and Search</h2>\n<p>Inside of the <code is:raw>main()</code> function, extract the podcast media URL, set transcription options, and request a Deepgram transcription. Finally, extract search results from the result:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> episode </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> episodes:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Get podcast episode URL</span></span>\n<span class="line"><span style="color: #C9D1D9">    source </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;url&#39;</span><span style="color: #C9D1D9">: episode.enclosures[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].href }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Increase chance of hearing brand_name</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Return search results for brand_name</span></span>\n<span class="line"><span style="color: #C9D1D9">    transcription_options </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;keywords&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">:2&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">: brand_name }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Request transcription</span></span>\n<span class="line"><span style="color: #C9D1D9">    response </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram.transcription.prerecorded(source, transcription_options)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Extract search results</span></span>\n<span class="line"><span style="color: #C9D1D9">    search_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response[</span><span style="color: #A5D6FF">&#39;results&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;channels&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;hits&#39;</span><span style="color: #C9D1D9">]</span></span></code></pre>\n<h3 id="filter-only-high-confidence-results">Filter Only High Confidence Results</h3>\n<p>Add the following line below <code is:raw>search_results</code> to filter out any values which are below the required confidence:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">strong_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">lambda</span><span style="color: #C9D1D9"> x: x[</span><span style="color: #A5D6FF">&#39;confidence&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> required_confidence, search_results))</span></span></code></pre>\n<h2 id="save-mentions-report">Save Mentions Report</h2>\n<p>Below <code is:raw>strong_results</code>, take each episode (and each result within the episode), and add it as a new line in a report file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E"># Define file name</span></span>\n<span class="line"><span style="color: #C9D1D9">filename </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-mentions-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">start_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-to-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">end_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">.txt&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">open</span><span style="color: #C9D1D9">(filename, </span><span style="color: #A5D6FF">&#39;a+&#39;</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> f:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Format publish date</span></span>\n<span class="line"><span style="color: #C9D1D9">    pub </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Create line per episode</span></span>\n<span class="line"><span style="color: #C9D1D9">    f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">pub</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">: &quot;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">episode.title</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">&quot; (</span><span style="color: #79C0FF">{len</span><span style="color: #C9D1D9">(strong_results)</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF"> mentions)</span><span style="color: #79C0FF">\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Create line per result (indented two spaces)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> result </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> strong_results:</span></span>\n<span class="line"><span style="color: #C9D1D9">        f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;  Mention at </span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">s of </span><span style="color: #79C0FF">\\&quot;{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;snippet&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}\\&quot;\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>That\u2019s it! Rerun the script with <code is:raw>python3 script.py</code> and, once completed, you should see a new file called <code is:raw>stellar-mentions-2022-05-01-to-2022-06-27.txt</code> - perfect if you want to run several reports.</p>\n<h2 id="extending-this-project">Extending This Project</h2>\n<p>This project should equip you with the information you need to understand if and how often brand mentions occur throughout several podcast episodes. You should extend this further by creating more complex or graphical reports, allowing several brands to be searched for in one request, or by building a UI around this logic.</p>\n<p>As ever, if you have any questions please feel free to get in touch or post in our <a href="https://github.com/orgs/deepgram/discussions">community discussions</a>.</p>\n<p>The final code is as follows:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> os</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> datetime </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> datetime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> time </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> mktime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> dotenv </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> load_dotenv</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> deepgram </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> Deepgram</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> feedparser</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">load_dotenv()</span></span>\n<span class="line"><span style="color: #C9D1D9">deepgram </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> Deepgram(os.getenv(</span><span style="color: #A5D6FF">&#39;DEEPGRAM_API_KEY&#39;</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">podcast_feed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;http://feeds.codenewbie.org/cnpodcast.xml&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">brand_name </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stellar&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">required_confidence </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.9</span></span>\n<span class="line"><span style="color: #C9D1D9">start_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-05-01&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">end_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-06-27&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    rss </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> feedparser.parse(podcast_feed)</span></span>\n<span class="line"><span style="color: #C9D1D9">    episodes </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(check_if_in_date_range, rss.entries))</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(episodes))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> episode </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> episodes:</span></span>\n<span class="line"><span style="color: #C9D1D9">        source </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;url&#39;</span><span style="color: #C9D1D9">: episode.enclosures[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].href }</span></span>\n<span class="line"><span style="color: #C9D1D9">        transcription_options </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;keywords&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">:2&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">: brand_name }</span></span>\n<span class="line"><span style="color: #C9D1D9">        response </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram.transcription.prerecorded(source, transcription_options)</span></span>\n<span class="line"><span style="color: #C9D1D9">        search_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response[</span><span style="color: #A5D6FF">&#39;results&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;channels&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;hits&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">        strong_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">lambda</span><span style="color: #C9D1D9"> x: x[</span><span style="color: #A5D6FF">&#39;confidence&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> required_confidence, search_results))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">        filename </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-mentions-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">start_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-to-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">end_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">.txt&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">open</span><span style="color: #C9D1D9">(filename, </span><span style="color: #A5D6FF">&#39;a+&#39;</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> f:</span></span>\n<span class="line"><span style="color: #C9D1D9">            pub </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">            f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">pub</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">: &quot;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">episode.title</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">&quot; (</span><span style="color: #79C0FF">{len</span><span style="color: #C9D1D9">(strong_results)</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF"> mentions)</span><span style="color: #79C0FF">\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> result </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> strong_results:</span></span>\n<span class="line"><span style="color: #C9D1D9">                f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;  Mention at </span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">s of </span><span style="color: #79C0FF">\\&quot;{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;snippet&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}\\&quot;\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">check_if_in_date_range</span><span style="color: #C9D1D9">(episode):</span></span>\n<span class="line"><span style="color: #C9D1D9">    date_with_time </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date_with_time.replace(</span><span style="color: #FFA657">hour</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">minute</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">second</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_before_start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(start_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_after_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&lt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(end_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> is_not_before_start </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> is_not_after_end</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    asyncio.run(main())</span></span></code></pre>' };
const frontmatter = { "title": "Track Brand Mentions Across Podcast Episodes", "description": "Learn how to generate a report for every podcast episode in a date range for mentions of your brand.", "date": "2022-09-13T09:01:01.100Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1662992286/blog/2022/09/find-podcast-brand-mentions/cover.jpg", "authors": ["kevin-lewis"], "category": "tutorial", "tags": ["python", "podcasts"], "shorturls": { "share": "https://dpgr.am/87bab2b", "twitter": "https://dpgr.am/b9de264", "linkedin": "https://dpgr.am/0ec29a6", "reddit": "https://dpgr.am/795f099", "facebook": "https://dpgr.am/8f5bfdf" }, "astro": { "headings": [{ "depth": 2, "slug": "before-you-start", "text": "Before You Start" }, { "depth": 2, "slug": "dependency-and-file-setup", "text": "Dependency and File Setup" }, { "depth": 2, "slug": "define-parameters", "text": "Define Parameters" }, { "depth": 2, "slug": "fetch-episodes-with-feedparser", "text": "Fetch Episodes with Feedparser" }, { "depth": 3, "slug": "filter-episodes-within-date-range", "text": "Filter Episodes Within Date Range" }, { "depth": 2, "slug": "transcribe-episodes-with-keyword-boosting-and-search", "text": "Transcribe Episodes with Keyword Boosting and Search" }, { "depth": 3, "slug": "filter-only-high-confidence-results", "text": "Filter Only High Confidence Results" }, { "depth": 2, "slug": "save-mentions-report", "text": "Save Mentions Report" }, { "depth": 2, "slug": "extending-this-project", "text": "Extending This Project" }], "source": "\nIn this post, we'll cover how to check podcast episodes for mentions of your brand. This can be particularly useful for ensuring sponsorship obligations are met, or to check when competitors are spoken about.\n\nGiven an input of a podcast feed URL, start/end dates, and a brand name, the script will generate a report of all mentions as detected by Deepgram's fast and accurate speech recognition API.\n\n## Before You Start\n\nYou must have Python installed on your machine - I'm using Python 3.10 at the time of writing. You will also need a Deepgram API Key - [get one here](https://console.deepgram.com/signup?jump=keys).\n\nCreate a new directory and navigate to it in your terminal. [Create a virtual environment](https://developers.deepgram.com/blog/2022/02/python-virtual-environments/) with `python3 -m venv virtual_env` and activate it with `source virtual_env/bin/activate`. Install dependencies with `pip install deepgram_sdk asyncio python-dotenv feedparser`.\n\nOpen the directory in a code editor, and create an empty `.env` file. Take your Deepgram API Key, and add the following line to `.env`:\n\n    DEEPGRAM_API_KEY=\"replace-this-bit-with-your-key\"\n\n## Dependency and File Setup\n\nCreate an empty `script.py` file and import the dependencies:\n\n```py\nimport os\nimport json\nfrom datetime import datetime\nfrom time import mktime\nimport asyncio\nfrom dotenv import load_dotenv\nfrom deepgram import Deepgram\nimport feedparser\n```\n\nLoad values from the `.env` file and initialize the Deepgram Python SDK:\n\n```py\nload_dotenv()\ndeepgram = Deepgram(os.getenv('DEEPGRAM_API_KEY'))\n```\n\nFinally, set up a `main()` function that is executed automatically when the script is run:\n\n```py\nasync def main():\n    print('Hello world')\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n## Define Parameters\n\nAbove the `main()` function, create a set of variables with settings for your report:\n\n```py\npodcast_feed = 'http://feeds.codenewbie.org/cnpodcast.xml' # CodeNewbie Podcast\nbrand_name = 'stellar'\nrequired_confidence = 0.9\nstart_date = '2022-05-01' # Start of season 20\nend_date = '2022-06-27' # End of season 20\n```\n\nEach time Deepgram returns a search result, it will come with a confidence between 0 and 1. The `required_confidence` value will only report results above the specified confidence level.\n\n## Fetch Episodes with Feedparser\n\nRemove the `print()` statement in the `main()` function, fetch the podcast, and take a look at the returned data by pretty-printing it:\n\n```py\nasync def main():\n    rss = feedparser.parse(podcast_feed)\n    print(json.dumps(rss.entries, indent=2))\n```\n\nTry it out! In your terminal, run the file with `python3 script.py` and you should see a bunch of data for each episode.\n\n### Filter Episodes Within Date Range\n\nFeedparser will take in many different date formats for when a RSS entry is published/updated and normalize them to a standard format. Using the standardized output, create a helper function just below the `main()` function:\n\n```py\ndef check_if_in_date_range(episode):\n    date_with_time = datetime.fromtimestamp(mktime(episode.published_parsed))\n    date = date_with_time.replace(hour=0, minute=0, second=0)\n    is_not_before_start = date >= datetime.fromisoformat(start_date)\n    is_not_after_end = date <= datetime.fromisoformat(end_date)\n    return is_not_before_start and is_not_after_end\n```\n\nThis function takes in an episode, gets the date (without time), and returns `True` if it is within the range between and including `start_date` and `end_date`.\n\nRemove `print(json.dumps(rss.entries, indent=2))` and replace it with the following:\n\n```py\nepisodes = list(filter(check_if_in_date_range, rss.entries))\n```\n\nThe `episodes` array now contains only episodes within the date range.\n\n## Transcribe Episodes with Keyword Boosting and Search\n\nInside of the `main()` function, extract the podcast media URL, set transcription options, and request a Deepgram transcription. Finally, extract search results from the result:\n\n```py\nfor episode in episodes:\n    # Get podcast episode URL\n    source = { 'url': episode.enclosures[0].href }\n    # Increase chance of hearing brand_name\n    # Return search results for brand_name\n    transcription_options = { 'keywords': f'{brand_name}:2', 'search': brand_name }\n    # Request transcription\n    response = await deepgram.transcription.prerecorded(source, transcription_options)\n    # Extract search results\n    search_results = response['results']['channels'][0]['search'][0]['hits']\n```\n\n### Filter Only High Confidence Results\n\nAdd the following line below `search_results` to filter out any values which are below the required confidence:\n\n```py\nstrong_results = list(filter(lambda x: x['confidence'] > required_confidence, search_results))\n```\n\n## Save Mentions Report\n\nBelow `strong_results`, take each episode (and each result within the episode), and add it as a new line in a report file:\n\n```py\n# Define file name\nfilename = f'{brand_name}-mentions-{start_date}-to-{end_date}.txt'\nwith open(filename, 'a+') as f:\n    # Format publish date\n    pub = datetime.fromtimestamp(mktime(episode.published_parsed))\n    # Create line per episode\n    f.write(f'{pub}: \"{episode.title}\" ({len(strong_results)} mentions)\\n')\n    # Create line per result (indented two spaces)\n    for result in strong_results:\n        f.write(f'  Mention at {result[\"start\"]}s of \\\"{result[\"snippet\"]}\\\"\\n')\n```\n\nThat's it! Rerun the script with `python3 script.py` and, once completed, you should see a new file called `stellar-mentions-2022-05-01-to-2022-06-27.txt` - perfect if you want to run several reports.\n\n## Extending This Project\n\nThis project should equip you with the information you need to understand if and how often brand mentions occur throughout several podcast episodes. You should extend this further by creating more complex or graphical reports, allowing several brands to be searched for in one request, or by building a UI around this logic.\n\nAs ever, if you have any questions please feel free to get in touch or post in our [community discussions](https://github.com/orgs/deepgram/discussions).\n\nThe final code is as follows:\n\n```py\nimport asyncio\nimport os\nfrom datetime import datetime\nfrom time import mktime\nfrom dotenv import load_dotenv\nfrom deepgram import Deepgram\nimport feedparser\n\nload_dotenv()\ndeepgram = Deepgram(os.getenv('DEEPGRAM_API_KEY'))\n\npodcast_feed = 'http://feeds.codenewbie.org/cnpodcast.xml'\nbrand_name = 'stellar'\nrequired_confidence = 0.9\nstart_date = '2022-05-01'\nend_date = '2022-06-27'\n\nasync def main():\n    rss = feedparser.parse(podcast_feed)\n    episodes = list(filter(check_if_in_date_range, rss.entries))\n    print(len(episodes))\n\n    for episode in episodes:\n        source = { 'url': episode.enclosures[0].href }\n        transcription_options = { 'keywords': f'{brand_name}:2', 'search': brand_name }\n        response = await deepgram.transcription.prerecorded(source, transcription_options)\n        search_results = response['results']['channels'][0]['search'][0]['hits']\n        strong_results = list(filter(lambda x: x['confidence'] > required_confidence, search_results))\n\n        filename = f'{brand_name}-mentions-{start_date}-to-{end_date}.txt'\n        with open(filename, 'a+') as f:\n            pub = datetime.fromtimestamp(mktime(episode.published_parsed))\n            f.write(f'{pub}: \"{episode.title}\" ({len(strong_results)} mentions)\\n')\n            for result in strong_results:\n                f.write(f'  Mention at {result[\"start\"]}s of \\\"{result[\"snippet\"]}\\\"\\n')\n\ndef check_if_in_date_range(episode):\n    date_with_time = datetime.fromtimestamp(mktime(episode.published_parsed))\n    date = date_with_time.replace(hour=0, minute=0, second=0)\n    is_not_before_start = date >= datetime.fromisoformat(start_date)\n    is_not_after_end = date <= datetime.fromisoformat(end_date)\n    return is_not_before_start and is_not_after_end\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n", "html": '<p>In this post, we\u2019ll cover how to check podcast episodes for mentions of your brand. This can be particularly useful for ensuring sponsorship obligations are met, or to check when competitors are spoken about.</p>\n<p>Given an input of a podcast feed URL, start/end dates, and a brand name, the script will generate a report of all mentions as detected by Deepgram\u2019s fast and accurate speech recognition API.</p>\n<h2 id="before-you-start">Before You Start</h2>\n<p>You must have Python installed on your machine - I\u2019m using Python 3.10 at the time of writing. You will also need a Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get one here</a>.</p>\n<p>Create a new directory and navigate to it in your terminal. <a href="https://developers.deepgram.com/blog/2022/02/python-virtual-environments/">Create a virtual environment</a> with <code is:raw>python3 -m venv virtual_env</code> and activate it with <code is:raw>source virtual_env/bin/activate</code>. Install dependencies with <code is:raw>pip install deepgram_sdk asyncio python-dotenv feedparser</code>.</p>\n<p>Open the directory in a code editor, and create an empty <code is:raw>.env</code> file. Take your Deepgram API Key, and add the following line to <code is:raw>.env</code>:</p>\n<p>DEEPGRAM_API_KEY=\u201Creplace-this-bit-with-your-key\u201D</p>\n<h2 id="dependency-and-file-setup">Dependency and File Setup</h2>\n<p>Create an empty <code is:raw>script.py</code> file and import the dependencies:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> os</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> datetime </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> datetime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> time </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> mktime</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> dotenv </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> load_dotenv</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> deepgram </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> Deepgram</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> feedparser</span></span></code></pre>\n<p>Load values from the <code is:raw>.env</code> file and initialize the Deepgram Python SDK:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">load_dotenv()</span></span>\n<span class="line"><span style="color: #C9D1D9">deepgram </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> Deepgram(os.getenv(</span><span style="color: #A5D6FF">&#39;DEEPGRAM_API_KEY&#39;</span><span style="color: #C9D1D9">))</span></span></code></pre>\n<p>Finally, set up a <code is:raw>main()</code> function that is executed automatically when the script is run:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Hello world&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    asyncio.run(main())</span></span></code></pre>\n<h2 id="define-parameters">Define Parameters</h2>\n<p>Above the <code is:raw>main()</code> function, create a set of variables with settings for your report:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">podcast_feed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;http://feeds.codenewbie.org/cnpodcast.xml&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># CodeNewbie Podcast</span></span>\n<span class="line"><span style="color: #C9D1D9">brand_name </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stellar&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">required_confidence </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.9</span></span>\n<span class="line"><span style="color: #C9D1D9">start_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-05-01&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># Start of season 20</span></span>\n<span class="line"><span style="color: #C9D1D9">end_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-06-27&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># End of season 20</span></span></code></pre>\n<p>Each time Deepgram returns a search result, it will come with a confidence between 0 and 1. The <code is:raw>required_confidence</code> value will only report results above the specified confidence level.</p>\n<h2 id="fetch-episodes-with-feedparser">Fetch Episodes with Feedparser</h2>\n<p>Remove the <code is:raw>print()</code> statement in the <code is:raw>main()</code> function, fetch the podcast, and take a look at the returned data by pretty-printing it:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    rss </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> feedparser.parse(podcast_feed)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(json.dumps(rss.entries, </span><span style="color: #FFA657">indent</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">))</span></span></code></pre>\n<p>Try it out! In your terminal, run the file with <code is:raw>python3 script.py</code> and you should see a bunch of data for each episode.</p>\n<h3 id="filter-episodes-within-date-range">Filter Episodes Within Date Range</h3>\n<p>Feedparser will take in many different date formats for when a RSS entry is published/updated and normalize them to a standard format. Using the standardized output, create a helper function just below the <code is:raw>main()</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">check_if_in_date_range</span><span style="color: #C9D1D9">(episode):</span></span>\n<span class="line"><span style="color: #C9D1D9">    date_with_time </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date_with_time.replace(</span><span style="color: #FFA657">hour</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">minute</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">second</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_before_start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(start_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_after_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&lt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(end_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> is_not_before_start </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> is_not_after_end</span></span></code></pre>\n<p>This function takes in an episode, gets the date (without time), and returns <code is:raw>True</code> if it is within the range between and including <code is:raw>start_date</code> and <code is:raw>end_date</code>.</p>\n<p>Remove <code is:raw>print(json.dumps(rss.entries, indent=2))</code> and replace it with the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">episodes </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(check_if_in_date_range, rss.entries))</span></span></code></pre>\n<p>The <code is:raw>episodes</code> array now contains only episodes within the date range.</p>\n<h2 id="transcribe-episodes-with-keyword-boosting-and-search">Transcribe Episodes with Keyword Boosting and Search</h2>\n<p>Inside of the <code is:raw>main()</code> function, extract the podcast media URL, set transcription options, and request a Deepgram transcription. Finally, extract search results from the result:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> episode </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> episodes:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Get podcast episode URL</span></span>\n<span class="line"><span style="color: #C9D1D9">    source </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;url&#39;</span><span style="color: #C9D1D9">: episode.enclosures[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].href }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Increase chance of hearing brand_name</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Return search results for brand_name</span></span>\n<span class="line"><span style="color: #C9D1D9">    transcription_options </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;keywords&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">:2&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">: brand_name }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Request transcription</span></span>\n<span class="line"><span style="color: #C9D1D9">    response </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram.transcription.prerecorded(source, transcription_options)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Extract search results</span></span>\n<span class="line"><span style="color: #C9D1D9">    search_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response[</span><span style="color: #A5D6FF">&#39;results&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;channels&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;hits&#39;</span><span style="color: #C9D1D9">]</span></span></code></pre>\n<h3 id="filter-only-high-confidence-results">Filter Only High Confidence Results</h3>\n<p>Add the following line below <code is:raw>search_results</code> to filter out any values which are below the required confidence:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">strong_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">lambda</span><span style="color: #C9D1D9"> x: x[</span><span style="color: #A5D6FF">&#39;confidence&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> required_confidence, search_results))</span></span></code></pre>\n<h2 id="save-mentions-report">Save Mentions Report</h2>\n<p>Below <code is:raw>strong_results</code>, take each episode (and each result within the episode), and add it as a new line in a report file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E"># Define file name</span></span>\n<span class="line"><span style="color: #C9D1D9">filename </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-mentions-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">start_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-to-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">end_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">.txt&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">open</span><span style="color: #C9D1D9">(filename, </span><span style="color: #A5D6FF">&#39;a+&#39;</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> f:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Format publish date</span></span>\n<span class="line"><span style="color: #C9D1D9">    pub </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Create line per episode</span></span>\n<span class="line"><span style="color: #C9D1D9">    f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">pub</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">: &quot;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">episode.title</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">&quot; (</span><span style="color: #79C0FF">{len</span><span style="color: #C9D1D9">(strong_results)</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF"> mentions)</span><span style="color: #79C0FF">\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Create line per result (indented two spaces)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> result </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> strong_results:</span></span>\n<span class="line"><span style="color: #C9D1D9">        f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;  Mention at </span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">s of </span><span style="color: #79C0FF">\\&quot;{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;snippet&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}\\&quot;\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>That\u2019s it! Rerun the script with <code is:raw>python3 script.py</code> and, once completed, you should see a new file called <code is:raw>stellar-mentions-2022-05-01-to-2022-06-27.txt</code> - perfect if you want to run several reports.</p>\n<h2 id="extending-this-project">Extending This Project</h2>\n<p>This project should equip you with the information you need to understand if and how often brand mentions occur throughout several podcast episodes. You should extend this further by creating more complex or graphical reports, allowing several brands to be searched for in one request, or by building a UI around this logic.</p>\n<p>As ever, if you have any questions please feel free to get in touch or post in our <a href="https://github.com/orgs/deepgram/discussions">community discussions</a>.</p>\n<p>The final code is as follows:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> os</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> datetime </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> datetime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> time </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> mktime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> dotenv </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> load_dotenv</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> deepgram </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> Deepgram</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> feedparser</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">load_dotenv()</span></span>\n<span class="line"><span style="color: #C9D1D9">deepgram </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> Deepgram(os.getenv(</span><span style="color: #A5D6FF">&#39;DEEPGRAM_API_KEY&#39;</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">podcast_feed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;http://feeds.codenewbie.org/cnpodcast.xml&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">brand_name </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stellar&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">required_confidence </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.9</span></span>\n<span class="line"><span style="color: #C9D1D9">start_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-05-01&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">end_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-06-27&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    rss </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> feedparser.parse(podcast_feed)</span></span>\n<span class="line"><span style="color: #C9D1D9">    episodes </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(check_if_in_date_range, rss.entries))</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(episodes))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> episode </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> episodes:</span></span>\n<span class="line"><span style="color: #C9D1D9">        source </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;url&#39;</span><span style="color: #C9D1D9">: episode.enclosures[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].href }</span></span>\n<span class="line"><span style="color: #C9D1D9">        transcription_options </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;keywords&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">:2&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">: brand_name }</span></span>\n<span class="line"><span style="color: #C9D1D9">        response </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram.transcription.prerecorded(source, transcription_options)</span></span>\n<span class="line"><span style="color: #C9D1D9">        search_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response[</span><span style="color: #A5D6FF">&#39;results&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;channels&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;hits&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">        strong_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">lambda</span><span style="color: #C9D1D9"> x: x[</span><span style="color: #A5D6FF">&#39;confidence&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> required_confidence, search_results))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">        filename </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-mentions-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">start_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-to-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">end_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">.txt&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">open</span><span style="color: #C9D1D9">(filename, </span><span style="color: #A5D6FF">&#39;a+&#39;</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> f:</span></span>\n<span class="line"><span style="color: #C9D1D9">            pub </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">            f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">pub</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">: &quot;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">episode.title</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">&quot; (</span><span style="color: #79C0FF">{len</span><span style="color: #C9D1D9">(strong_results)</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF"> mentions)</span><span style="color: #79C0FF">\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> result </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> strong_results:</span></span>\n<span class="line"><span style="color: #C9D1D9">                f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;  Mention at </span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">s of </span><span style="color: #79C0FF">\\&quot;{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;snippet&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}\\&quot;\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">check_if_in_date_range</span><span style="color: #C9D1D9">(episode):</span></span>\n<span class="line"><span style="color: #C9D1D9">    date_with_time </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date_with_time.replace(</span><span style="color: #FFA657">hour</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">minute</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">second</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_before_start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(start_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_after_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&lt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(end_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> is_not_before_start </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> is_not_after_end</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    asyncio.run(main())</span></span></code></pre>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/track-brand-mentions-across-podcast-episodes/index.md" };
function rawContent() {
  return "\nIn this post, we'll cover how to check podcast episodes for mentions of your brand. This can be particularly useful for ensuring sponsorship obligations are met, or to check when competitors are spoken about.\n\nGiven an input of a podcast feed URL, start/end dates, and a brand name, the script will generate a report of all mentions as detected by Deepgram's fast and accurate speech recognition API.\n\n## Before You Start\n\nYou must have Python installed on your machine - I'm using Python 3.10 at the time of writing. You will also need a Deepgram API Key - [get one here](https://console.deepgram.com/signup?jump=keys).\n\nCreate a new directory and navigate to it in your terminal. [Create a virtual environment](https://developers.deepgram.com/blog/2022/02/python-virtual-environments/) with `python3 -m venv virtual_env` and activate it with `source virtual_env/bin/activate`. Install dependencies with `pip install deepgram_sdk asyncio python-dotenv feedparser`.\n\nOpen the directory in a code editor, and create an empty `.env` file. Take your Deepgram API Key, and add the following line to `.env`:\n\n    DEEPGRAM_API_KEY=\"replace-this-bit-with-your-key\"\n\n## Dependency and File Setup\n\nCreate an empty `script.py` file and import the dependencies:\n\n```py\nimport os\nimport json\nfrom datetime import datetime\nfrom time import mktime\nimport asyncio\nfrom dotenv import load_dotenv\nfrom deepgram import Deepgram\nimport feedparser\n```\n\nLoad values from the `.env` file and initialize the Deepgram Python SDK:\n\n```py\nload_dotenv()\ndeepgram = Deepgram(os.getenv('DEEPGRAM_API_KEY'))\n```\n\nFinally, set up a `main()` function that is executed automatically when the script is run:\n\n```py\nasync def main():\n    print('Hello world')\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n## Define Parameters\n\nAbove the `main()` function, create a set of variables with settings for your report:\n\n```py\npodcast_feed = 'http://feeds.codenewbie.org/cnpodcast.xml' # CodeNewbie Podcast\nbrand_name = 'stellar'\nrequired_confidence = 0.9\nstart_date = '2022-05-01' # Start of season 20\nend_date = '2022-06-27' # End of season 20\n```\n\nEach time Deepgram returns a search result, it will come with a confidence between 0 and 1. The `required_confidence` value will only report results above the specified confidence level.\n\n## Fetch Episodes with Feedparser\n\nRemove the `print()` statement in the `main()` function, fetch the podcast, and take a look at the returned data by pretty-printing it:\n\n```py\nasync def main():\n    rss = feedparser.parse(podcast_feed)\n    print(json.dumps(rss.entries, indent=2))\n```\n\nTry it out! In your terminal, run the file with `python3 script.py` and you should see a bunch of data for each episode.\n\n### Filter Episodes Within Date Range\n\nFeedparser will take in many different date formats for when a RSS entry is published/updated and normalize them to a standard format. Using the standardized output, create a helper function just below the `main()` function:\n\n```py\ndef check_if_in_date_range(episode):\n    date_with_time = datetime.fromtimestamp(mktime(episode.published_parsed))\n    date = date_with_time.replace(hour=0, minute=0, second=0)\n    is_not_before_start = date >= datetime.fromisoformat(start_date)\n    is_not_after_end = date <= datetime.fromisoformat(end_date)\n    return is_not_before_start and is_not_after_end\n```\n\nThis function takes in an episode, gets the date (without time), and returns `True` if it is within the range between and including `start_date` and `end_date`.\n\nRemove `print(json.dumps(rss.entries, indent=2))` and replace it with the following:\n\n```py\nepisodes = list(filter(check_if_in_date_range, rss.entries))\n```\n\nThe `episodes` array now contains only episodes within the date range.\n\n## Transcribe Episodes with Keyword Boosting and Search\n\nInside of the `main()` function, extract the podcast media URL, set transcription options, and request a Deepgram transcription. Finally, extract search results from the result:\n\n```py\nfor episode in episodes:\n    # Get podcast episode URL\n    source = { 'url': episode.enclosures[0].href }\n    # Increase chance of hearing brand_name\n    # Return search results for brand_name\n    transcription_options = { 'keywords': f'{brand_name}:2', 'search': brand_name }\n    # Request transcription\n    response = await deepgram.transcription.prerecorded(source, transcription_options)\n    # Extract search results\n    search_results = response['results']['channels'][0]['search'][0]['hits']\n```\n\n### Filter Only High Confidence Results\n\nAdd the following line below `search_results` to filter out any values which are below the required confidence:\n\n```py\nstrong_results = list(filter(lambda x: x['confidence'] > required_confidence, search_results))\n```\n\n## Save Mentions Report\n\nBelow `strong_results`, take each episode (and each result within the episode), and add it as a new line in a report file:\n\n```py\n# Define file name\nfilename = f'{brand_name}-mentions-{start_date}-to-{end_date}.txt'\nwith open(filename, 'a+') as f:\n    # Format publish date\n    pub = datetime.fromtimestamp(mktime(episode.published_parsed))\n    # Create line per episode\n    f.write(f'{pub}: \"{episode.title}\" ({len(strong_results)} mentions)\\n')\n    # Create line per result (indented two spaces)\n    for result in strong_results:\n        f.write(f'  Mention at {result[\"start\"]}s of \\\"{result[\"snippet\"]}\\\"\\n')\n```\n\nThat's it! Rerun the script with `python3 script.py` and, once completed, you should see a new file called `stellar-mentions-2022-05-01-to-2022-06-27.txt` - perfect if you want to run several reports.\n\n## Extending This Project\n\nThis project should equip you with the information you need to understand if and how often brand mentions occur throughout several podcast episodes. You should extend this further by creating more complex or graphical reports, allowing several brands to be searched for in one request, or by building a UI around this logic.\n\nAs ever, if you have any questions please feel free to get in touch or post in our [community discussions](https://github.com/orgs/deepgram/discussions).\n\nThe final code is as follows:\n\n```py\nimport asyncio\nimport os\nfrom datetime import datetime\nfrom time import mktime\nfrom dotenv import load_dotenv\nfrom deepgram import Deepgram\nimport feedparser\n\nload_dotenv()\ndeepgram = Deepgram(os.getenv('DEEPGRAM_API_KEY'))\n\npodcast_feed = 'http://feeds.codenewbie.org/cnpodcast.xml'\nbrand_name = 'stellar'\nrequired_confidence = 0.9\nstart_date = '2022-05-01'\nend_date = '2022-06-27'\n\nasync def main():\n    rss = feedparser.parse(podcast_feed)\n    episodes = list(filter(check_if_in_date_range, rss.entries))\n    print(len(episodes))\n\n    for episode in episodes:\n        source = { 'url': episode.enclosures[0].href }\n        transcription_options = { 'keywords': f'{brand_name}:2', 'search': brand_name }\n        response = await deepgram.transcription.prerecorded(source, transcription_options)\n        search_results = response['results']['channels'][0]['search'][0]['hits']\n        strong_results = list(filter(lambda x: x['confidence'] > required_confidence, search_results))\n\n        filename = f'{brand_name}-mentions-{start_date}-to-{end_date}.txt'\n        with open(filename, 'a+') as f:\n            pub = datetime.fromtimestamp(mktime(episode.published_parsed))\n            f.write(f'{pub}: \"{episode.title}\" ({len(strong_results)} mentions)\\n')\n            for result in strong_results:\n                f.write(f'  Mention at {result[\"start\"]}s of \\\"{result[\"snippet\"]}\\\"\\n')\n\ndef check_if_in_date_range(episode):\n    date_with_time = datetime.fromtimestamp(mktime(episode.published_parsed))\n    date = date_with_time.replace(hour=0, minute=0, second=0)\n    is_not_before_start = date >= datetime.fromisoformat(start_date)\n    is_not_after_end = date <= datetime.fromisoformat(end_date)\n    return is_not_before_start and is_not_after_end\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n";
}
function compiledContent() {
  return '<p>In this post, we\u2019ll cover how to check podcast episodes for mentions of your brand. This can be particularly useful for ensuring sponsorship obligations are met, or to check when competitors are spoken about.</p>\n<p>Given an input of a podcast feed URL, start/end dates, and a brand name, the script will generate a report of all mentions as detected by Deepgram\u2019s fast and accurate speech recognition API.</p>\n<h2 id="before-you-start">Before You Start</h2>\n<p>You must have Python installed on your machine - I\u2019m using Python 3.10 at the time of writing. You will also need a Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get one here</a>.</p>\n<p>Create a new directory and navigate to it in your terminal. <a href="https://developers.deepgram.com/blog/2022/02/python-virtual-environments/">Create a virtual environment</a> with <code is:raw>python3 -m venv virtual_env</code> and activate it with <code is:raw>source virtual_env/bin/activate</code>. Install dependencies with <code is:raw>pip install deepgram_sdk asyncio python-dotenv feedparser</code>.</p>\n<p>Open the directory in a code editor, and create an empty <code is:raw>.env</code> file. Take your Deepgram API Key, and add the following line to <code is:raw>.env</code>:</p>\n<p>DEEPGRAM_API_KEY=\u201Creplace-this-bit-with-your-key\u201D</p>\n<h2 id="dependency-and-file-setup">Dependency and File Setup</h2>\n<p>Create an empty <code is:raw>script.py</code> file and import the dependencies:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> os</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> datetime </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> datetime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> time </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> mktime</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> dotenv </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> load_dotenv</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> deepgram </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> Deepgram</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> feedparser</span></span></code></pre>\n<p>Load values from the <code is:raw>.env</code> file and initialize the Deepgram Python SDK:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">load_dotenv()</span></span>\n<span class="line"><span style="color: #C9D1D9">deepgram </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> Deepgram(os.getenv(</span><span style="color: #A5D6FF">&#39;DEEPGRAM_API_KEY&#39;</span><span style="color: #C9D1D9">))</span></span></code></pre>\n<p>Finally, set up a <code is:raw>main()</code> function that is executed automatically when the script is run:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Hello world&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    asyncio.run(main())</span></span></code></pre>\n<h2 id="define-parameters">Define Parameters</h2>\n<p>Above the <code is:raw>main()</code> function, create a set of variables with settings for your report:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">podcast_feed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;http://feeds.codenewbie.org/cnpodcast.xml&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># CodeNewbie Podcast</span></span>\n<span class="line"><span style="color: #C9D1D9">brand_name </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stellar&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">required_confidence </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.9</span></span>\n<span class="line"><span style="color: #C9D1D9">start_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-05-01&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># Start of season 20</span></span>\n<span class="line"><span style="color: #C9D1D9">end_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-06-27&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># End of season 20</span></span></code></pre>\n<p>Each time Deepgram returns a search result, it will come with a confidence between 0 and 1. The <code is:raw>required_confidence</code> value will only report results above the specified confidence level.</p>\n<h2 id="fetch-episodes-with-feedparser">Fetch Episodes with Feedparser</h2>\n<p>Remove the <code is:raw>print()</code> statement in the <code is:raw>main()</code> function, fetch the podcast, and take a look at the returned data by pretty-printing it:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    rss </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> feedparser.parse(podcast_feed)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(json.dumps(rss.entries, </span><span style="color: #FFA657">indent</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">))</span></span></code></pre>\n<p>Try it out! In your terminal, run the file with <code is:raw>python3 script.py</code> and you should see a bunch of data for each episode.</p>\n<h3 id="filter-episodes-within-date-range">Filter Episodes Within Date Range</h3>\n<p>Feedparser will take in many different date formats for when a RSS entry is published/updated and normalize them to a standard format. Using the standardized output, create a helper function just below the <code is:raw>main()</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">check_if_in_date_range</span><span style="color: #C9D1D9">(episode):</span></span>\n<span class="line"><span style="color: #C9D1D9">    date_with_time </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date_with_time.replace(</span><span style="color: #FFA657">hour</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">minute</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">second</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_before_start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(start_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_after_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&lt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(end_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> is_not_before_start </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> is_not_after_end</span></span></code></pre>\n<p>This function takes in an episode, gets the date (without time), and returns <code is:raw>True</code> if it is within the range between and including <code is:raw>start_date</code> and <code is:raw>end_date</code>.</p>\n<p>Remove <code is:raw>print(json.dumps(rss.entries, indent=2))</code> and replace it with the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">episodes </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(check_if_in_date_range, rss.entries))</span></span></code></pre>\n<p>The <code is:raw>episodes</code> array now contains only episodes within the date range.</p>\n<h2 id="transcribe-episodes-with-keyword-boosting-and-search">Transcribe Episodes with Keyword Boosting and Search</h2>\n<p>Inside of the <code is:raw>main()</code> function, extract the podcast media URL, set transcription options, and request a Deepgram transcription. Finally, extract search results from the result:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> episode </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> episodes:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Get podcast episode URL</span></span>\n<span class="line"><span style="color: #C9D1D9">    source </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;url&#39;</span><span style="color: #C9D1D9">: episode.enclosures[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].href }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Increase chance of hearing brand_name</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Return search results for brand_name</span></span>\n<span class="line"><span style="color: #C9D1D9">    transcription_options </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;keywords&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">:2&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">: brand_name }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Request transcription</span></span>\n<span class="line"><span style="color: #C9D1D9">    response </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram.transcription.prerecorded(source, transcription_options)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Extract search results</span></span>\n<span class="line"><span style="color: #C9D1D9">    search_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response[</span><span style="color: #A5D6FF">&#39;results&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;channels&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;hits&#39;</span><span style="color: #C9D1D9">]</span></span></code></pre>\n<h3 id="filter-only-high-confidence-results">Filter Only High Confidence Results</h3>\n<p>Add the following line below <code is:raw>search_results</code> to filter out any values which are below the required confidence:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">strong_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">lambda</span><span style="color: #C9D1D9"> x: x[</span><span style="color: #A5D6FF">&#39;confidence&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> required_confidence, search_results))</span></span></code></pre>\n<h2 id="save-mentions-report">Save Mentions Report</h2>\n<p>Below <code is:raw>strong_results</code>, take each episode (and each result within the episode), and add it as a new line in a report file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E"># Define file name</span></span>\n<span class="line"><span style="color: #C9D1D9">filename </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-mentions-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">start_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-to-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">end_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">.txt&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">open</span><span style="color: #C9D1D9">(filename, </span><span style="color: #A5D6FF">&#39;a+&#39;</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> f:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Format publish date</span></span>\n<span class="line"><span style="color: #C9D1D9">    pub </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Create line per episode</span></span>\n<span class="line"><span style="color: #C9D1D9">    f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">pub</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">: &quot;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">episode.title</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">&quot; (</span><span style="color: #79C0FF">{len</span><span style="color: #C9D1D9">(strong_results)</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF"> mentions)</span><span style="color: #79C0FF">\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Create line per result (indented two spaces)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> result </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> strong_results:</span></span>\n<span class="line"><span style="color: #C9D1D9">        f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;  Mention at </span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">s of </span><span style="color: #79C0FF">\\&quot;{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;snippet&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}\\&quot;\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>That\u2019s it! Rerun the script with <code is:raw>python3 script.py</code> and, once completed, you should see a new file called <code is:raw>stellar-mentions-2022-05-01-to-2022-06-27.txt</code> - perfect if you want to run several reports.</p>\n<h2 id="extending-this-project">Extending This Project</h2>\n<p>This project should equip you with the information you need to understand if and how often brand mentions occur throughout several podcast episodes. You should extend this further by creating more complex or graphical reports, allowing several brands to be searched for in one request, or by building a UI around this logic.</p>\n<p>As ever, if you have any questions please feel free to get in touch or post in our <a href="https://github.com/orgs/deepgram/discussions">community discussions</a>.</p>\n<p>The final code is as follows:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> os</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> datetime </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> datetime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> time </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> mktime</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> dotenv </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> load_dotenv</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> deepgram </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> Deepgram</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> feedparser</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">load_dotenv()</span></span>\n<span class="line"><span style="color: #C9D1D9">deepgram </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> Deepgram(os.getenv(</span><span style="color: #A5D6FF">&#39;DEEPGRAM_API_KEY&#39;</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">podcast_feed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;http://feeds.codenewbie.org/cnpodcast.xml&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">brand_name </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stellar&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">required_confidence </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.9</span></span>\n<span class="line"><span style="color: #C9D1D9">start_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-05-01&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">end_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-06-27&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">    rss </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> feedparser.parse(podcast_feed)</span></span>\n<span class="line"><span style="color: #C9D1D9">    episodes </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(check_if_in_date_range, rss.entries))</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(episodes))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> episode </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> episodes:</span></span>\n<span class="line"><span style="color: #C9D1D9">        source </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;url&#39;</span><span style="color: #C9D1D9">: episode.enclosures[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].href }</span></span>\n<span class="line"><span style="color: #C9D1D9">        transcription_options </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;keywords&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">:2&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">: brand_name }</span></span>\n<span class="line"><span style="color: #C9D1D9">        response </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram.transcription.prerecorded(source, transcription_options)</span></span>\n<span class="line"><span style="color: #C9D1D9">        search_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response[</span><span style="color: #A5D6FF">&#39;results&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;channels&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;hits&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">        strong_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">lambda</span><span style="color: #C9D1D9"> x: x[</span><span style="color: #A5D6FF">&#39;confidence&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> required_confidence, search_results))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">        filename </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-mentions-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">start_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-to-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">end_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">.txt&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">open</span><span style="color: #C9D1D9">(filename, </span><span style="color: #A5D6FF">&#39;a+&#39;</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> f:</span></span>\n<span class="line"><span style="color: #C9D1D9">            pub </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">            f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">pub</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">: &quot;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">episode.title</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">&quot; (</span><span style="color: #79C0FF">{len</span><span style="color: #C9D1D9">(strong_results)</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF"> mentions)</span><span style="color: #79C0FF">\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> result </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> strong_results:</span></span>\n<span class="line"><span style="color: #C9D1D9">                f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;  Mention at </span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">s of </span><span style="color: #79C0FF">\\&quot;{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;snippet&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}\\&quot;\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">check_if_in_date_range</span><span style="color: #C9D1D9">(episode):</span></span>\n<span class="line"><span style="color: #C9D1D9">    date_with_time </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>\n<span class="line"><span style="color: #C9D1D9">    date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date_with_time.replace(</span><span style="color: #FFA657">hour</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">minute</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">second</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_before_start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(start_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    is_not_after_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&lt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(end_date)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> is_not_before_start </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> is_not_after_end</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    asyncio.run(main())</span></span></code></pre>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/track-brand-mentions-across-podcast-episodes/index.md", "", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>In this post, well cover how to check podcast episodes for mentions of your brand. This can be particularly useful for ensuring sponsorship obligations are met, or to check when competitors are spoken about.</p>
<p>Given an input of a podcast feed URL, start/end dates, and a brand name, the script will generate a report of all mentions as detected by Deepgrams fast and accurate speech recognition API.</p>
<h2 id="before-you-start">Before You Start</h2>
<p>You must have Python installed on your machine - Im using Python 3.10 at the time of writing. You will also need a Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get one here</a>.</p>
<p>Create a new directory and navigate to it in your terminal. <a href="https://developers.deepgram.com/blog/2022/02/python-virtual-environments/">Create a virtual environment</a> with <code>python3 -m venv virtual_env</code> and activate it with <code>source virtual_env/bin/activate</code>. Install dependencies with <code>pip install deepgram_sdk asyncio python-dotenv feedparser</code>.</p>
<p>Open the directory in a code editor, and create an empty <code>.env</code> file. Take your Deepgram API Key, and add the following line to <code>.env</code>:</p>
<p>DEEPGRAM_API_KEY=replace-this-bit-with-your-key</p>
<h2 id="dependency-and-file-setup">Dependency and File Setup</h2>
<p>Create an empty <code>script.py</code> file and import the dependencies:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> os</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> datetime </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> datetime</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> time </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> mktime</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> dotenv </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> load_dotenv</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> deepgram </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> Deepgram</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> feedparser</span></span></code></pre>
<p>Load values from the <code>.env</code> file and initialize the Deepgram Python SDK:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">load_dotenv()</span></span>
<span class="line"><span style="color: #C9D1D9">deepgram </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> Deepgram(os.getenv(</span><span style="color: #A5D6FF">&#39;DEEPGRAM_API_KEY&#39;</span><span style="color: #C9D1D9">))</span></span></code></pre>
<p>Finally, set up a <code>main()</code> function that is executed automatically when the script is run:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Hello world&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.run(main())</span></span></code></pre>
<h2 id="define-parameters">Define Parameters</h2>
<p>Above the <code>main()</code> function, create a set of variables with settings for your report:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">podcast_feed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;http://feeds.codenewbie.org/cnpodcast.xml&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># CodeNewbie Podcast</span></span>
<span class="line"><span style="color: #C9D1D9">brand_name </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stellar&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">required_confidence </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.9</span></span>
<span class="line"><span style="color: #C9D1D9">start_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-05-01&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># Start of season 20</span></span>
<span class="line"><span style="color: #C9D1D9">end_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-06-27&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># End of season 20</span></span></code></pre>
<p>Each time Deepgram returns a search result, it will come with a confidence between 0 and 1. The <code>required_confidence</code> value will only report results above the specified confidence level.</p>
<h2 id="fetch-episodes-with-feedparser">Fetch Episodes with Feedparser</h2>
<p>Remove the <code>print()</code> statement in the <code>main()</code> function, fetch the podcast, and take a look at the returned data by pretty-printing it:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    rss </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> feedparser.parse(podcast_feed)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(json.dumps(rss.entries, </span><span style="color: #FFA657">indent</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">))</span></span></code></pre>
<p>Try it out! In your terminal, run the file with <code>python3 script.py</code> and you should see a bunch of data for each episode.</p>
<h3 id="filter-episodes-within-date-range">Filter Episodes Within Date Range</h3>
<p>Feedparser will take in many different date formats for when a RSS entry is published/updated and normalize them to a standard format. Using the standardized output, create a helper function just below the <code>main()</code> function:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">check_if_in_date_range</span><span style="color: #C9D1D9">(episode):</span></span>
<span class="line"><span style="color: #C9D1D9">    date_with_time </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>
<span class="line"><span style="color: #C9D1D9">    date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date_with_time.replace(</span><span style="color: #FFA657">hour</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">minute</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">second</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    is_not_before_start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(start_date)</span></span>
<span class="line"><span style="color: #C9D1D9">    is_not_after_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&lt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(end_date)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> is_not_before_start </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> is_not_after_end</span></span></code></pre>
<p>This function takes in an episode, gets the date (without time), and returns <code>True</code> if it is within the range between and including <code>start_date</code> and <code>end_date</code>.</p>
<p>Remove <code>print(json.dumps(rss.entries, indent=2))</code> and replace it with the following:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">episodes </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(check_if_in_date_range, rss.entries))</span></span></code></pre>
<p>The <code>episodes</code> array now contains only episodes within the date range.</p>
<h2 id="transcribe-episodes-with-keyword-boosting-and-search">Transcribe Episodes with Keyword Boosting and Search</h2>
<p>Inside of the <code>main()</code> function, extract the podcast media URL, set transcription options, and request a Deepgram transcription. Finally, extract search results from the result:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> episode </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> episodes:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Get podcast episode URL</span></span>
<span class="line"><span style="color: #C9D1D9">    source </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;url&#39;</span><span style="color: #C9D1D9">: episode.enclosures[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].href }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Increase chance of hearing brand_name</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Return search results for brand_name</span></span>
<span class="line"><span style="color: #C9D1D9">    transcription_options </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;keywords&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">:2&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">: brand_name }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Request transcription</span></span>
<span class="line"><span style="color: #C9D1D9">    response </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram.transcription.prerecorded(source, transcription_options)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Extract search results</span></span>
<span class="line"><span style="color: #C9D1D9">    search_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response[</span><span style="color: #A5D6FF">&#39;results&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;channels&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;hits&#39;</span><span style="color: #C9D1D9">]</span></span></code></pre>
<h3 id="filter-only-high-confidence-results">Filter Only High Confidence Results</h3>
<p>Add the following line below <code>search_results</code> to filter out any values which are below the required confidence:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">strong_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">lambda</span><span style="color: #C9D1D9"> x: x[</span><span style="color: #A5D6FF">&#39;confidence&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> required_confidence, search_results))</span></span></code></pre>
<h2 id="save-mentions-report">Save Mentions Report</h2>
<p>Below <code>strong_results</code>, take each episode (and each result within the episode), and add it as a new line in a report file:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E"># Define file name</span></span>
<span class="line"><span style="color: #C9D1D9">filename </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-mentions-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">start_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-to-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">end_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">.txt&#39;</span></span>
<span class="line"><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">open</span><span style="color: #C9D1D9">(filename, </span><span style="color: #A5D6FF">&#39;a+&#39;</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> f:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Format publish date</span></span>
<span class="line"><span style="color: #C9D1D9">    pub </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Create line per episode</span></span>
<span class="line"><span style="color: #C9D1D9">    f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">pub</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">: &quot;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">episode.title</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">&quot; (</span><span style="color: #79C0FF">{len</span><span style="color: #C9D1D9">(strong_results)</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF"> mentions)</span><span style="color: #79C0FF">\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># Create line per result (indented two spaces)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> result </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> strong_results:</span></span>
<span class="line"><span style="color: #C9D1D9">        f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;  Mention at </span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">s of </span><span style="color: #79C0FF">\\&quot;{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;snippet&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}\\&quot;\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>Thats it! Rerun the script with <code>python3 script.py</code> and, once completed, you should see a new file called <code>stellar-mentions-2022-05-01-to-2022-06-27.txt</code> - perfect if you want to run several reports.</p>
<h2 id="extending-this-project">Extending This Project</h2>
<p>This project should equip you with the information you need to understand if and how often brand mentions occur throughout several podcast episodes. You should extend this further by creating more complex or graphical reports, allowing several brands to be searched for in one request, or by building a UI around this logic.</p>
<p>As ever, if you have any questions please feel free to get in touch or post in our <a href="https://github.com/orgs/deepgram/discussions">community discussions</a>.</p>
<p>The final code is as follows:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> os</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> datetime </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> datetime</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> time </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> mktime</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> dotenv </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> load_dotenv</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> deepgram </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> Deepgram</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> feedparser</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">load_dotenv()</span></span>
<span class="line"><span style="color: #C9D1D9">deepgram </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> Deepgram(os.getenv(</span><span style="color: #A5D6FF">&#39;DEEPGRAM_API_KEY&#39;</span><span style="color: #C9D1D9">))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">podcast_feed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;http://feeds.codenewbie.org/cnpodcast.xml&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">brand_name </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stellar&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">required_confidence </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.9</span></span>
<span class="line"><span style="color: #C9D1D9">start_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-05-01&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">end_date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;2022-06-27&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    rss </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> feedparser.parse(podcast_feed)</span></span>
<span class="line"><span style="color: #C9D1D9">    episodes </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(check_if_in_date_range, rss.entries))</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(episodes))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> episode </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> episodes:</span></span>
<span class="line"><span style="color: #C9D1D9">        source </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;url&#39;</span><span style="color: #C9D1D9">: episode.enclosures[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].href }</span></span>
<span class="line"><span style="color: #C9D1D9">        transcription_options </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #A5D6FF">&#39;keywords&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">:2&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">: brand_name }</span></span>
<span class="line"><span style="color: #C9D1D9">        response </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram.transcription.prerecorded(source, transcription_options)</span></span>
<span class="line"><span style="color: #C9D1D9">        search_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response[</span><span style="color: #A5D6FF">&#39;results&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;channels&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;search&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;hits&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">        strong_results </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">filter</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">lambda</span><span style="color: #C9D1D9"> x: x[</span><span style="color: #A5D6FF">&#39;confidence&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> required_confidence, search_results))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        filename </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">brand_name</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-mentions-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">start_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">-to-</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">end_date</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">.txt&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">open</span><span style="color: #C9D1D9">(filename, </span><span style="color: #A5D6FF">&#39;a+&#39;</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> f:</span></span>
<span class="line"><span style="color: #C9D1D9">            pub </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>
<span class="line"><span style="color: #C9D1D9">            f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">pub</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">: &quot;</span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">episode.title</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">&quot; (</span><span style="color: #79C0FF">{len</span><span style="color: #C9D1D9">(strong_results)</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF"> mentions)</span><span style="color: #79C0FF">\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> result </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> strong_results:</span></span>
<span class="line"><span style="color: #C9D1D9">                f.write(</span><span style="color: #FF7B72">f</span><span style="color: #A5D6FF">&#39;  Mention at </span><span style="color: #79C0FF">{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}</span><span style="color: #A5D6FF">s of </span><span style="color: #79C0FF">\\&quot;{</span><span style="color: #C9D1D9">result[</span><span style="color: #A5D6FF">&quot;snippet&quot;</span><span style="color: #C9D1D9">]</span><span style="color: #79C0FF">}\\&quot;\\n</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">check_if_in_date_range</span><span style="color: #C9D1D9">(episode):</span></span>
<span class="line"><span style="color: #C9D1D9">    date_with_time </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> datetime.fromtimestamp(mktime(episode.published_parsed))</span></span>
<span class="line"><span style="color: #C9D1D9">    date </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date_with_time.replace(</span><span style="color: #FFA657">hour</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">minute</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">second</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    is_not_before_start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(start_date)</span></span>
<span class="line"><span style="color: #C9D1D9">    is_not_after_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> date </span><span style="color: #FF7B72">&lt;=</span><span style="color: #C9D1D9"> datetime.fromisoformat(end_date)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> is_not_before_start </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> is_not_after_end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.run(main())</span></span></code></pre>`;
});

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
