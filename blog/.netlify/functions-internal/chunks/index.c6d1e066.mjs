import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
/* empty css                           */import 'axios';
/* empty css                          *//* empty css                           *//* empty css                          *//* empty css                              *//* empty css                              */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           *//* empty css                              */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "pre-requisites", "text": "Pre-requisites" }, { "depth": 2, "slug": "setting-up-a-twiml-bin", "text": "Setting Up A TwiML Bin" }, { "depth": 2, "slug": "the-twilio-proxy-server", "text": "The Twilio Proxy Server" }, { "depth": 2, "slug": "running-the-server-and-testing-with-websocat", "text": "Running the Server and Testing with WebSocat" }, { "depth": 2, "slug": "further-development", "text": "Further Development" }], "source": "\nTwilio is a very popular voice platform, and Deepgram is a great automatic speech recognition (ASR) solution, so there\r\nis great value in integrating the two. This tutorial will guide you through building an integration that allows\r\nmultiple client subscribers to watch live transcripts from ongoing Twilio calls. The code for this tutorial\r\nis located [here](https://github.com/deepgram-devs/deepgram-twilio-streaming-python).\n\n## Pre-requisites\n\nYou will need:\n\n*   A [Twilio account](https://www.twilio.com/try-twilio) with a Twilio number (the free tier will work).\n*   A Deepgram API Key - [get an API Key here](https://console.deepgram.com/signup?jump=keys).\n*   *(Optional)* [ngrok](https://ngrok.com/) to let Twilio access a local server.\n\n## Setting Up A TwiML Bin\n\nWe need to tell Twilio to fork audio data from calls going to your Twilio number to the server we are going to write.\r\nThis is done via \"TwiML Bin\"s. In the Twilio Console, search for TwiML Bin, and click \"Create TwiML Bin.\"\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648782300/blog/2022/04/deepgram-twilio-streaming/assets/find_twiml_bin.png\" alt=\"Navigate to your TwiML Bins.\" style=\"max-width: 606px;display: block;margin-left: auto;margin-right: auto;\">\n\nGive the TwiML Bin a \"Friendly Name\" - something like \"Streaming\" or \"Deepgram Streaming,\" and then make the contents of the TwiML Bin the following:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Response>\r\n  <Start>\r\n    <Stream url=\"wss://INSERT_YOUR_SERVER_URL/twilio\" track=\"both_tracks\"/>\r\n  </Start>\r\n  <Say voice=\"woman\" language=\"en\">\"This call may be monitored or recorded for quality purposes.\"</Say>\r\n  <Dial>+11231231234</Dial>\r\n</Response>\n```\n\nReplace the number in the `Dial` section with the phone number you want incoming calls to be forwarded to (this should not be\r\nyour Twilio number, it should be the number of a real phone in your possession!). Then, where it says `INSERT_YOUR_SERVER_URL`\r\ntype in the URL where you will be running your server. Without having to setup an AWS or DigitalOcean server, you can use\r\n`ngrok` to expose a local server. To expose port 5000 on your computer, you can use ngrok as follows:\n\n```bash\nngrok http 5000\n```\n\n`ngrok` will then tell you the public URL which points to your `localhost:5000`. Your URL may\r\nend up looking something like: `c52e-71-212-124-133.ngrok.io`.\n\nNow, we need to connect this TwiML Bin to your Twilio phone number. Go to the \"Develop\" tab on the left side\r\nof the Twilio Console, navigate to `Phone Numbers -> Manage -> Active numbers`, and click on your Twilio number\r\nin the list. Then, under the field \"A Call Comes In,\" click the drop-down and select \"TwiML Bin\"; for the field\r\ndirectly next to this one, click the drop-down and select \"Streaming\" (or whatever your TwiML Bin's \"Friendly Name\" is).\r\nFinally, click \"Save\" at the bottom of the Twilio Console. Everything on Twilio's side should now be set up, and we\r\nare ready to move on to the Deepgram integration server!\n\n## The Twilio Proxy Server\n\nLet's take a look at the system we are building here:\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648783494/blog/2022/04/deepgram-twilio-streaming/assets/deepgram_twilio_diagram.png\" alt=\"The big picture.\" style=\"max-width: 2096px;display: block;margin-left: auto;margin-right: auto;\">\n\nWe have pairs of callers, inbound and outbound, and, for each call passing through Twilio's servers, Twilio is able to fork the audio from the call\r\nto our proxy server via websockets. Our server then has to do some light processing of that audio, forward it on to Deepgram, receive transcripts\r\nback from Deepgram, and forward those transcripts on to potentially multiple clients who are subscribed to watch the call's transcripts. So in order\r\nto view real-time transcripts in a client application, our backend server must maintain a minimum of three websockets connections - we can see how\r\nthis can get complicated, especially when dealing with many concurrent Twilio calls and subscribed clients!\n\nDownload the code from [this repository](https://github.com/deepgram-devs/deepgram-twilio-streaming-python). It contains a single file, `twilio.py`!\n\nLet's look at the code (make sure to replace `INSERT_YOUR_DEEPGRAM_API_KEY` with your Deepgram API Key):\n\n```python\nimport asyncio\r\nimport base64\r\nimport json\r\nimport sys\r\nimport websockets\r\nimport ssl\r\nfrom pydub import AudioSegment\r\n\r\nsubscribers = {}\r\n\r\ndef deepgram_connect():\r\n extra_headers = {\r\n  'Authorization': 'Token INSERT_YOUR_DEEPGRAM_API_KEY'\r\n }\r\n deepgram_ws = websockets.connect('wss://api.deepgram.com/v1/listen?encoding=mulaw&sample_rate=8000&channels=2&multichannel=true', extra_headers = extra_headers)\r\n\r\n return deepgram_ws\r\n\r\nasync def twilio_handler(twilio_ws):\r\n audio_queue = asyncio.Queue()\r\n callsid_queue = asyncio.Queue()\r\n\r\n async with deepgram_connect() as deepgram_ws:\r\n\r\n  async def deepgram_sender(deepgram_ws):\r\n   print('deepgram_sender started')\r\n   while True:\r\n    chunk = await audio_queue.get()\r\n    await deepgram_ws.send(chunk)\r\n\r\n  async def deepgram_receiver(deepgram_ws):\r\n   print('deepgram_receiver started')\r\n   # we will wait until the twilio ws connection figures out the callsid\r\n   # then we will initialize our subscribers list for this callsid\r\n   callsid = await callsid_queue.get()\r\n   subscribers[callsid] = []\r\n   # for each deepgram result received, forward it on to all\r\n   # queues subscribed to the twilio callsid\r\n   async for message in deepgram_ws:\r\n    for client in subscribers[callsid]:\r\n     client.put_nowait(message)\r\n\r\n   # once the twilio call is over, tell all subscribed clients to close\r\n   # and remove the subscriber list for this callsid\r\n   for client in subscribers[callsid]:\r\n    client.put_nowait('close')\r\n\r\n   del subscribers[callsid]\r\n\r\n  async def twilio_receiver(twilio_ws):\r\n   print('twilio_receiver started')\r\n   # twilio sends audio data as 160 byte messages containing 20ms of audio each\r\n   # we will buffer 20 twilio messages corresponding to 0.4 seconds of audio to improve throughput performance\r\n   BUFFER_SIZE = 20 * 160\r\n   # the algorithm to deal with mixing the two channels is somewhat complex\r\n   # here we implement an algorithm which fills in silence for channels if that channel is either\r\n   #   A) not currently streaming (e.g. the outbound channel when the inbound channel starts ringing it)\r\n   #   B) packets are dropped (this happens, and sometimes the timestamps which come back for subsequent packets are not aligned)\r\n   inbuffer = bytearray(b'')\r\n   outbuffer = bytearray(b'')\r\n   inbound_chunks_started = False\r\n   outbound_chunks_started = False\r\n   latest_inbound_timestamp = 0\r\n   latest_outbound_timestamp = 0\r\n   async for message in twilio_ws:\r\n    try:\r\n     data = json.loads(message)\r\n     if data['event'] == 'start':\r\n      start = data['start']\r\n      callsid = start['callSid']\r\n      callsid_queue.put_nowait(callsid)\r\n     if data['event'] == 'connected':\r\n      continue\r\n     if data['event'] == 'media':\r\n      media = data['media']\r\n      chunk = base64.b64decode(media['payload'])\r\n      if media['track'] == 'inbound':\r\n       # fills in silence if there have been dropped packets\r\n       if inbound_chunks_started:\r\n        if latest_inbound_timestamp + 20 < int(media['timestamp']):\r\n         bytes_to_fill = 8 * (int(media['timestamp']) - (latest_inbound_timestamp + 20))\r\n         # NOTE: 0xff is silence for mulaw audio\r\n         # and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)\r\n         inbuffer.extend(b'\\xff' * bytes_to_fill)\r\n       else:\r\n        # make it known that inbound chunks have started arriving\r\n        inbound_chunks_started = True\r\n        latest_inbound_timestamp = int(media['timestamp'])\r\n        # this basically sets the starting point for outbound timestamps\r\n        latest_outbound_timestamp = int(media['timestamp']) - 20\r\n       latest_inbound_timestamp = int(media['timestamp'])\r\n       # extend the inbound audio buffer with data\r\n       inbuffer.extend(chunk)\r\n      if media['track'] == 'outbound':\r\n       # make it known that outbound chunks have started arriving\r\n       outbound_chunked_started = True\r\n       # fills in silence if there have been dropped packets\r\n       if latest_outbound_timestamp + 20 < int(media['timestamp']):\r\n        bytes_to_fill = 8 * (int(media['timestamp']) - (latest_outbound_timestamp + 20))\r\n        # NOTE: 0xff is silence for mulaw audio\r\n        # and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)\r\n        outbuffer.extend(b'\\xff' * bytes_to_fill)\r\n       latest_outbound_timestamp = int(media['timestamp'])\r\n       # extend the outbound audio buffer with data\r\n       outbuffer.extend(chunk)\r\n     if data['event'] == 'stop':\r\n      break\r\n\r\n     # check if our buffer is ready to send to our audio_queue (and, thus, then to deepgram)\r\n     while len(inbuffer) >= BUFFER_SIZE and len(outbuffer) >= BUFFER_SIZE:\r\n      asinbound = AudioSegment(inbuffer[:BUFFER_SIZE], sample_width=1, frame_rate=8000, channels=1)\r\n      asoutbound = AudioSegment(outbuffer[:BUFFER_SIZE], sample_width=1, frame_rate=8000, channels=1)\r\n      mixed = AudioSegment.from_mono_audiosegments(asinbound, asoutbound)\r\n\r\n      # sending to deepgram via the audio_queue\r\n      audio_queue.put_nowait(mixed.raw_data)\r\n\r\n      # clearing buffers\r\n      inbuffer = inbuffer[BUFFER_SIZE:]\r\n      outbuffer = outbuffer[BUFFER_SIZE:]\r\n    except:\r\n     break\r\n\r\n   # the async for loop will end if the ws connection from twilio dies\r\n   # and if this happens, we should forward an empty byte to deepgram\r\n   # to signal deepgram to send back remaining messages before closing\r\n   audio_queue.put_nowait(b'')\r\n\r\n  await asyncio.wait([\r\n   asyncio.ensure_future(deepgram_sender(deepgram_ws)),\r\n   asyncio.ensure_future(deepgram_receiver(deepgram_ws)),\r\n   asyncio.ensure_future(twilio_receiver(twilio_ws))\r\n  ])\r\n\r\n  await twilio_ws.close()\r\n\r\nasync def client_handler(client_ws):\r\n client_queue = asyncio.Queue()\r\n\r\n # first tell the client all active calls\r\n await client_ws.send(json.dumps(list(subscribers.keys())))\r\n\r\n # then recieve from the client which call they would like to subscribe to\r\n # and add our client's queue to the subscriber list for that call\r\n try:\r\n  # you may want to parse a proper json input here\r\n  # instead of grabbing the entire message as the callsid verbatim\r\n  callsid = await client_ws.recv()\r\n  callsid = callsid.strip()\r\n  if callsid in subscribers:\r\n   subscribers[callsid].append(client_queue)\r\n  else:\r\n   await client_ws.close()\r\n except:\r\n  await client_ws.close()\r\n\r\n async def client_sender(client_ws):\r\n  while True:\r\n   message = await client_queue.get()\r\n   if message == 'close':\r\n    break\r\n   try:\r\n    await client_ws.send(message)\r\n   except:\r\n    # if there was an error, remove this client queue\r\n    subscribers[callsid].remove(client_queue)\r\n    break\r\n\r\n await asyncio.wait([\r\n  asyncio.ensure_future(client_sender(client_ws)),\r\n ])\r\n\r\n await client_ws.close()\r\n\r\nasync def router(websocket, path):\r\n if path == '/client':\r\n  print('client connection incoming')\r\n  await client_handler(websocket)\r\n elif path == '/twilio':\r\n  print('twilio connection incoming')\r\n  await twilio_handler(websocket)\r\n\r\ndef main():\r\n # use this if using ssl\r\n# ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\r\n# ssl_context.load_cert_chain('cert.pem', 'key.pem')\r\n# server = websockets.serve(router, '0.0.0.0', 443, ssl=ssl_context)\r\n\r\n # use this if not using ssl\r\n server = websockets.serve(router, 'localhost', 5000)\r\n\r\n asyncio.get_event_loop().run_until_complete(server)\r\n asyncio.get_event_loop().run_forever()\r\n\r\nif __name__ == '__main__':\r\n sys.exit(main() or 0)\n```\n\nThis server uses the Python `websocket` library to connect to Twilio, Deepgram, and client applications, and the `asyncio` library to handle\r\nconcurrent connections. The server has two routes: `/twilio` and `/client`. As we have configured in our TwiML Bin, Twilio will be connecting\r\nto and sending audio data to the `/twilio` endpoint, and we will use the `/client` endpoint for client applications which will watch the\r\nstreaming transcripts.\n\nThe server uses a dictionary, called `subscribers`, to handle concurrent connected clients. Specifically, `subscribers` is a dictionary\r\nwhose keys are Twilio `callSid`s which uniquely identify calls, and whose values are a list of queues for clients who are \"subscribed\"\r\nto those calls (i.e. watching for streaming transcripts from those calls).\n\nTo dive into the code, let's look at the `client_handler` function. When a client connects to the `/client` endpoint, the `client_handler`\r\nfunction will first send a websocket message to the client listing the `callSid`s of all currently streaming calls. The function then waits\r\nto receive a websocket message which it expects to be the `callSid` of the call that the client wants to view live transcripts for\r\n(and if the function does not receive a valid `callSid`, it will bail). Having received a valid `callSid`, the function then inserts\r\nthis client's queue into the `subscribers` dictionary and starts an async task which reads from this queue, sending transcription\r\nresults back to the client via websocket messages, or gracefully closing the websocket connection if the message \"close\" was received on the queue.\n\nNow let's jump into the more involved `twilio_handler` function. This function handles incoming websocket connections from Twilio,\r\nand begins by setting up a queue for audio data, and a queue to handle passing the incoming `callSid` between async tasks.\r\nIt then connects to Deepgram and sets up three async tasks: `deepgram_receiver`, `deepgram_sender`, and `twilio_receiver` (we will\r\nnever send websocket messages back to Twilio, hence no \"twilio\\_sender\" task).\n\nThe `twilio_receiver` task handles incoming [websocket messages](https://www.twilio.com/docs/voice/twiml/stream#websocket-messages-from-twilio) from Twilio.\r\nBefore Twilio sends audio data, it will send some metadata as part of a `start` event. One of these pieces of metadata is the `callSid`\r\nof the call, and we will pass that on to the `deepgram_receiver` task via a queue. Then, when Twilio starts streaming `media` (i.e. audio)\r\nevents, we will perform some logic to buffer and mix this audio. In particular, Twilio will stream audio in via separate `inbound`\r\nand `outbound` audio tracks; we must make sure we mix these two audio tracks together as correct stereo audio to pass on to Deepgram.\r\nSome issues arise if call packets are dropped from one of these tracks, and logic is implemented with ample comments to deal with this\r\nwithout having the two channels in the mixed stereo audio get out of sync. Finally, with correctly mixed audio buffers prepared,\r\n`twilio_receiver` will pass this audio on to the `deepgram_sender` task via a queue. The `deepgram_sender` task then simply passes\r\nthis audio on to Deepgram via the Deepgram websocket handle.\n\nFinally, we get to the `deepgram_receiver` task. In order to pass transcripts from Deepgram on to subscribed clients, we must first\r\nknow the `callSid` of the call, so the first thing `deepgram_receiver` does is wait to obtain this from the `twilio_receiver` via\r\na queue. Once the `callSid` is obtained, the `deepgram_receiver` is then able to forward on all transcription results from Deepgram\r\nto all clients subscribed to that `callSid`. It does this via another queue, which is handled by the async task defined in `client_handler`,\r\nand thus we come full circle.\n\n## Running the Server and Testing with WebSocat\n\nTo run the server, first `pip3 install` the `websockets`, `pydub`, and `asyncio` libraries, and then run:\n\n```bash\npython3 twilio.py\n```\n\nIf you are running this on your own cloud server, make sure port 5000 is accessible. If you followed the optional\r\nsuggestion of using `ngrok`, this should be all set up simply by running `ngrok http 5000` on a separate terminal.\n\nTo quickly test the integration, start a call to your Twilio number - this call will be forwarded to the phone number\r\nin the `Dial` section of your TwiML Bin, so you will need two phones (so feel free to grab a friend, or set up\r\na Google Voice account or something similar!).\n\nAfter the phone call has started, use a tool like [websocat](https://github.com/vi/websocat#installation) to connect\r\nto `ws://localhost:5000/client`. Upon connecting, the server should output a list of the `callSid`s of ongoing calls\r\n(it should be a list of exactly one call at this point); reply to the server with one of these `callSid`s and watch\r\nthe Deepgram transcription responses roll in! You can start multiple clients and have them all subscribe to the\r\nsame `callSid` to see how a concurrent system could work.\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1649269367/blog/2022/04/deepgram-twilio-streaming/assets/websocat_screenshot.png\" alt=\"Using websocat to view the transcripts.\" style=\"max-width: 1623px;display: block;margin-left: auto;margin-right: auto;\">\n\n## Further Development\n\nThe Deepgram-Twilio integration design presented here is slightly opinionated, in the interest of getting\r\na reasonably complete demo up and running. You may want to factor in authentication, as the `/client` endpoint\r\nexplained here is completely unauthenticated. You also may want to find an alternate way of labelling calls\r\nto subscribe to - instead of grabbing `callSid`s, one could subscribe directly to Twilio numbers, but this\r\nwould require extra Twilio API integration to look up the status of calls to your Twilio numbers.\n\nAnother clear next step would be to develop a proper client application. Programs like `websocat` are fantastic\r\nfor testing, but you will likely want to design a front-end application which handles selecting `callSid`s\r\nto subscribe to, parses and formats the Deepgram transcription response, and possibly other features.\n\nIf you have any questions, please feel free to reach out on Twitter - we're [@DeepgramDevs](https://twitter.com/DeepgramDevs).\n\n        ", "html": '<p>Twilio is a very popular voice platform, and Deepgram is a great automatic speech recognition (ASR) solution, so there\r\nis great value in integrating the two. This tutorial will guide you through building an integration that allows\r\nmultiple client subscribers to watch live transcripts from ongoing Twilio calls. The code for this tutorial\r\nis located <a href="https://github.com/deepgram-devs/deepgram-twilio-streaming-python">here</a>.</p>\n<h2 id="pre-requisites">Pre-requisites</h2>\n<p>You will need:</p>\n<ul>\n<li>A <a href="https://www.twilio.com/try-twilio">Twilio account</a> with a Twilio number (the free tier will work).</li>\n<li>A Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get an API Key here</a>.</li>\n<li><em>(Optional)</em> <a href="https://ngrok.com/">ngrok</a> to let Twilio access a local server.</li>\n</ul>\n<h2 id="setting-up-a-twiml-bin">Setting Up A TwiML Bin</h2>\n<p>We need to tell Twilio to fork audio data from calls going to your Twilio number to the server we are going to write.\r\nThis is done via \u201CTwiML Bin\u201Ds. In the Twilio Console, search for TwiML Bin, and click \u201CCreate TwiML Bin.\u201D</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648782300/blog/2022/04/deepgram-twilio-streaming/assets/find_twiml_bin.png" alt="Navigate to your TwiML Bins." style="max-width: 606px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Give the TwiML Bin a \u201CFriendly Name\u201D - something like \u201CStreaming\u201D or \u201CDeepgram Streaming,\u201D and then make the contents of the TwiML Bin the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;?</span><span style="color: #7EE787">xml</span><span style="color: #79C0FF"> version</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;1.0&quot;</span><span style="color: #79C0FF"> encoding</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;UTF-8&quot;</span><span style="color: #C9D1D9">?&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">Response</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Start</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">Stream</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">url</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;wss://INSERT_YOUR_SERVER_URL/twilio&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">track</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;both_tracks&quot;</span><span style="color: #C9D1D9">/&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">Start</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Say</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">voice</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;woman&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">language</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;en&quot;</span><span style="color: #C9D1D9">&gt;&quot;This call may be monitored or recorded for quality purposes.&quot;&lt;/</span><span style="color: #7EE787">Say</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Dial</span><span style="color: #C9D1D9">&gt;+11231231234&lt;/</span><span style="color: #7EE787">Dial</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">Response</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Replace the number in the <code is:raw>Dial</code> section with the phone number you want incoming calls to be forwarded to (this should not be\r\nyour Twilio number, it should be the number of a real phone in your possession!). Then, where it says <code is:raw>INSERT_YOUR_SERVER_URL</code>\r\ntype in the URL where you will be running your server. Without having to setup an AWS or DigitalOcean server, you can use\r\n<code is:raw>ngrok</code> to expose a local server. To expose port 5000 on your computer, you can use ngrok as follows:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">ngrok http 5000</span></span></code></pre>\n<p><code is:raw>ngrok</code> will then tell you the public URL which points to your <code is:raw>localhost:5000</code>. Your URL may\r\nend up looking something like: <code is:raw>c52e-71-212-124-133.ngrok.io</code>.</p>\n<p>Now, we need to connect this TwiML Bin to your Twilio phone number. Go to the \u201CDevelop\u201D tab on the left side\r\nof the Twilio Console, navigate to <code is:raw>Phone Numbers -&gt; Manage -&gt; Active numbers</code>, and click on your Twilio number\r\nin the list. Then, under the field \u201CA Call Comes In,\u201D click the drop-down and select \u201CTwiML Bin\u201D; for the field\r\ndirectly next to this one, click the drop-down and select \u201CStreaming\u201D (or whatever your TwiML Bin\u2019s \u201CFriendly Name\u201D is).\r\nFinally, click \u201CSave\u201D at the bottom of the Twilio Console. Everything on Twilio\u2019s side should now be set up, and we\r\nare ready to move on to the Deepgram integration server!</p>\n<h2 id="the-twilio-proxy-server">The Twilio Proxy Server</h2>\n<p>Let\u2019s take a look at the system we are building here:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648783494/blog/2022/04/deepgram-twilio-streaming/assets/deepgram_twilio_diagram.png" alt="The big picture." style="max-width: 2096px;display: block;margin-left: auto;margin-right: auto;" />\n<p>We have pairs of callers, inbound and outbound, and, for each call passing through Twilio\u2019s servers, Twilio is able to fork the audio from the call\r\nto our proxy server via websockets. Our server then has to do some light processing of that audio, forward it on to Deepgram, receive transcripts\r\nback from Deepgram, and forward those transcripts on to potentially multiple clients who are subscribed to watch the call\u2019s transcripts. So in order\r\nto view real-time transcripts in a client application, our backend server must maintain a minimum of three websockets connections - we can see how\r\nthis can get complicated, especially when dealing with many concurrent Twilio calls and subscribed clients!</p>\n<p>Download the code from <a href="https://github.com/deepgram-devs/deepgram-twilio-streaming-python">this repository</a>. It contains a single file, <code is:raw>twilio.py</code>!</p>\n<p>Let\u2019s look at the code (make sure to replace <code is:raw>INSERT_YOUR_DEEPGRAM_API_KEY</code> with your Deepgram API Key):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> base64</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> ssl</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> pydub </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> AudioSegment</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">subscribers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_connect</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9"> extra_headers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token INSERT_YOUR_DEEPGRAM_API_KEY&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9"> deepgram_ws </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> websockets.connect(</span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?encoding=mulaw&amp;sample_rate=8000&amp;channels=2&amp;multichannel=true&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">extra_headers</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> extra_headers)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> deepgram_ws</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">twilio_handler</span><span style="color: #C9D1D9">(twilio_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9"> audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"><span style="color: #C9D1D9"> callsid_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> deepgram_connect() </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> deepgram_ws:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_sender</span><span style="color: #C9D1D9">(deepgram_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;deepgram_sender started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    chunk </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram_ws.send(chunk)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_receiver</span><span style="color: #C9D1D9">(deepgram_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;deepgram_receiver started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># we will wait until the twilio ws connection figures out the callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># then we will initialize our subscribers list for this callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> callsid_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">   subscribers[callsid] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> []</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># for each deepgram result received, forward it on to all</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># queues subscribed to the twilio callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> deepgram_ws:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> client </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers[callsid]:</span></span>\n<span class="line"><span style="color: #C9D1D9">     client.put_nowait(message)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># once the twilio call is over, tell all subscribed clients to close</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># and remove the subscriber list for this callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> client </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers[callsid]:</span></span>\n<span class="line"><span style="color: #C9D1D9">    client.put_nowait(</span><span style="color: #A5D6FF">&#39;close&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">del</span><span style="color: #C9D1D9"> subscribers[callsid]</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">twilio_receiver</span><span style="color: #C9D1D9">(twilio_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;twilio_receiver started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># twilio sends audio data as 160 byte messages containing 20ms of audio each</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># we will buffer 20 twilio messages corresponding to 0.4 seconds of audio to improve throughput performance</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">160</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># the algorithm to deal with mixing the two channels is somewhat complex</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># here we implement an algorithm which fills in silence for channels if that channel is either</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">#   A) not currently streaming (e.g. the outbound channel when the inbound channel starts ringing it)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">#   B) packets are dropped (this happens, and sometimes the timestamps which come back for subsequent packets are not aligned)</span></span>\n<span class="line"><span style="color: #C9D1D9">   inbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">bytearray</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   outbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">bytearray</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   inbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>\n<span class="line"><span style="color: #C9D1D9">   outbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>\n<span class="line"><span style="color: #C9D1D9">   latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">   latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> twilio_ws:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">     data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(message)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> start[</span><span style="color: #A5D6FF">&#39;callSid&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      callsid_queue.put_nowait(callsid)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;connected&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">continue</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;media&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      media </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;media&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      chunk </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> base64.b64decode(media[</span><span style="color: #A5D6FF">&#39;payload&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> media[</span><span style="color: #A5D6FF">&#39;track&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;inbound&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># fills in silence if there have been dropped packets</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> inbound_chunks_started:</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> latest_inbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]):</span></span>\n<span class="line"><span style="color: #C9D1D9">         bytes_to_fill </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> (</span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> (latest_inbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"><span style="color: #C9D1D9">         </span><span style="color: #8B949E"># </span><span style="color: #FF7B72">NOTE</span><span style="color: #8B949E">: 0xff is silence for mulaw audio</span></span>\n<span class="line"><span style="color: #C9D1D9">         </span><span style="color: #8B949E"># and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)</span></span>\n<span class="line"><span style="color: #C9D1D9">         inbuffer.extend(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\xff</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> bytes_to_fill)</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># make it known that inbound chunks have started arriving</span></span>\n<span class="line"><span style="color: #C9D1D9">        inbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>\n<span class="line"><span style="color: #C9D1D9">        latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># this basically sets the starting point for outbound timestamps</span></span>\n<span class="line"><span style="color: #C9D1D9">        latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span></span>\n<span class="line"><span style="color: #C9D1D9">       latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># extend the inbound audio buffer with data</span></span>\n<span class="line"><span style="color: #C9D1D9">       inbuffer.extend(chunk)</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> media[</span><span style="color: #A5D6FF">&#39;track&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;outbound&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># make it known that outbound chunks have started arriving</span></span>\n<span class="line"><span style="color: #C9D1D9">       outbound_chunked_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># fills in silence if there have been dropped packets</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> latest_outbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]):</span></span>\n<span class="line"><span style="color: #C9D1D9">        bytes_to_fill </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> (</span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> (latest_outbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># </span><span style="color: #FF7B72">NOTE</span><span style="color: #8B949E">: 0xff is silence for mulaw audio</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)</span></span>\n<span class="line"><span style="color: #C9D1D9">        outbuffer.extend(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\xff</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> bytes_to_fill)</span></span>\n<span class="line"><span style="color: #C9D1D9">       latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># extend the outbound audio buffer with data</span></span>\n<span class="line"><span style="color: #C9D1D9">       outbuffer.extend(chunk)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stop&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #8B949E"># check if our buffer is ready to send to our audio_queue (and, thus, then to deepgram)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(inbuffer) </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(outbuffer) </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      asinbound </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment(inbuffer[:</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">sample_width</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">frame_rate</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">8000</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">channels</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">      asoutbound </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment(outbuffer[:</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">sample_width</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">frame_rate</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">8000</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">channels</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">      mixed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment.from_mono_audiosegments(asinbound, asoutbound)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E"># sending to deepgram via the audio_queue</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio_queue.put_nowait(mixed.raw_data)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E"># clearing buffers</span></span>\n<span class="line"><span style="color: #C9D1D9">      inbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> inbuffer[</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:]</span></span>\n<span class="line"><span style="color: #C9D1D9">      outbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> outbuffer[</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:]</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># the async for loop will end if the ws connection from twilio dies</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># and if this happens, we should forward an empty byte to deepgram</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># to signal deepgram to send back remaining messages before closing</span></span>\n<span class="line"><span style="color: #C9D1D9">   audio_queue.put_nowait(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(deepgram_sender(deepgram_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(deepgram_receiver(deepgram_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(twilio_receiver(twilio_ws))</span></span>\n<span class="line"><span style="color: #C9D1D9">  ])</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> twilio_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">client_handler</span><span style="color: #C9D1D9">(client_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9"> client_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># first tell the client all active calls</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.send(json.dumps(</span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(subscribers.keys())))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># then recieve from the client which call they would like to subscribe to</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># and add our client&#39;s queue to the subscriber list for that call</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E"># you may want to parse a proper json input here</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E"># instead of grabbing the entire message as the callsid verbatim</span></span>\n<span class="line"><span style="color: #C9D1D9">  callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.recv()</span></span>\n<span class="line"><span style="color: #C9D1D9">  callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callsid.strip()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> callsid </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers:</span></span>\n<span class="line"><span style="color: #C9D1D9">   subscribers[callsid].append(client_queue)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">client_sender</span><span style="color: #C9D1D9">(client_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">   message </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;close&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">break</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.send(message)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># if there was an error, remove this client queue</span></span>\n<span class="line"><span style="color: #C9D1D9">    subscribers[callsid].remove(client_queue)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>\n<span class="line"><span style="color: #C9D1D9">  asyncio.ensure_future(client_sender(client_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9"> ])</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">router</span><span style="color: #C9D1D9">(websocket, path):</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> path </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;/client&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;client connection incoming&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_handler(websocket)</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">elif</span><span style="color: #C9D1D9"> path </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;/twilio&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;twilio connection incoming&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> twilio_handler(websocket)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># use this if using ssl</span></span>\n<span class="line"><span style="color: #8B949E"># ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)</span></span>\n<span class="line"><span style="color: #8B949E"># ssl_context.load_cert_chain(&#39;cert.pem&#39;, &#39;key.pem&#39;)</span></span>\n<span class="line"><span style="color: #8B949E"># server = websockets.serve(router, &#39;0.0.0.0&#39;, 443, ssl=ssl_context)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># use this if not using ssl</span></span>\n<span class="line"><span style="color: #C9D1D9"> server </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> websockets.serve(router, </span><span style="color: #A5D6FF">&#39;localhost&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">5000</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> asyncio.get_event_loop().run_until_complete(server)</span></span>\n<span class="line"><span style="color: #C9D1D9"> asyncio.get_event_loop().run_forever()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9"> sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>This server uses the Python <code is:raw>websocket</code> library to connect to Twilio, Deepgram, and client applications, and the <code is:raw>asyncio</code> library to handle\r\nconcurrent connections. The server has two routes: <code is:raw>/twilio</code> and <code is:raw>/client</code>. As we have configured in our TwiML Bin, Twilio will be connecting\r\nto and sending audio data to the <code is:raw>/twilio</code> endpoint, and we will use the <code is:raw>/client</code> endpoint for client applications which will watch the\r\nstreaming transcripts.</p>\n<p>The server uses a dictionary, called <code is:raw>subscribers</code>, to handle concurrent connected clients. Specifically, <code is:raw>subscribers</code> is a dictionary\r\nwhose keys are Twilio <code is:raw>callSid</code>s which uniquely identify calls, and whose values are a list of queues for clients who are \u201Csubscribed\u201D\r\nto those calls (i.e. watching for streaming transcripts from those calls).</p>\n<p>To dive into the code, let\u2019s look at the <code is:raw>client_handler</code> function. When a client connects to the <code is:raw>/client</code> endpoint, the <code is:raw>client_handler</code>\r\nfunction will first send a websocket message to the client listing the <code is:raw>callSid</code>s of all currently streaming calls. The function then waits\r\nto receive a websocket message which it expects to be the <code is:raw>callSid</code> of the call that the client wants to view live transcripts for\r\n(and if the function does not receive a valid <code is:raw>callSid</code>, it will bail). Having received a valid <code is:raw>callSid</code>, the function then inserts\r\nthis client\u2019s queue into the <code is:raw>subscribers</code> dictionary and starts an async task which reads from this queue, sending transcription\r\nresults back to the client via websocket messages, or gracefully closing the websocket connection if the message \u201Cclose\u201D was received on the queue.</p>\n<p>Now let\u2019s jump into the more involved <code is:raw>twilio_handler</code> function. This function handles incoming websocket connections from Twilio,\r\nand begins by setting up a queue for audio data, and a queue to handle passing the incoming <code is:raw>callSid</code> between async tasks.\r\nIt then connects to Deepgram and sets up three async tasks: <code is:raw>deepgram_receiver</code>, <code is:raw>deepgram_sender</code>, and <code is:raw>twilio_receiver</code> (we will\r\nnever send websocket messages back to Twilio, hence no \u201Ctwilio_sender\u201D task).</p>\n<p>The <code is:raw>twilio_receiver</code> task handles incoming <a href="https://www.twilio.com/docs/voice/twiml/stream#websocket-messages-from-twilio">websocket messages</a> from Twilio.\r\nBefore Twilio sends audio data, it will send some metadata as part of a <code is:raw>start</code> event. One of these pieces of metadata is the <code is:raw>callSid</code>\r\nof the call, and we will pass that on to the <code is:raw>deepgram_receiver</code> task via a queue. Then, when Twilio starts streaming <code is:raw>media</code> (i.e. audio)\r\nevents, we will perform some logic to buffer and mix this audio. In particular, Twilio will stream audio in via separate <code is:raw>inbound</code>\r\nand <code is:raw>outbound</code> audio tracks; we must make sure we mix these two audio tracks together as correct stereo audio to pass on to Deepgram.\r\nSome issues arise if call packets are dropped from one of these tracks, and logic is implemented with ample comments to deal with this\r\nwithout having the two channels in the mixed stereo audio get out of sync. Finally, with correctly mixed audio buffers prepared,\r\n<code is:raw>twilio_receiver</code> will pass this audio on to the <code is:raw>deepgram_sender</code> task via a queue. The <code is:raw>deepgram_sender</code> task then simply passes\r\nthis audio on to Deepgram via the Deepgram websocket handle.</p>\n<p>Finally, we get to the <code is:raw>deepgram_receiver</code> task. In order to pass transcripts from Deepgram on to subscribed clients, we must first\r\nknow the <code is:raw>callSid</code> of the call, so the first thing <code is:raw>deepgram_receiver</code> does is wait to obtain this from the <code is:raw>twilio_receiver</code> via\r\na queue. Once the <code is:raw>callSid</code> is obtained, the <code is:raw>deepgram_receiver</code> is then able to forward on all transcription results from Deepgram\r\nto all clients subscribed to that <code is:raw>callSid</code>. It does this via another queue, which is handled by the async task defined in <code is:raw>client_handler</code>,\r\nand thus we come full circle.</p>\n<h2 id="running-the-server-and-testing-with-websocat">Running the Server and Testing with WebSocat</h2>\n<p>To run the server, first <code is:raw>pip3 install</code> the <code is:raw>websockets</code>, <code is:raw>pydub</code>, and <code is:raw>asyncio</code> libraries, and then run:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">python3 twilio.py</span></span></code></pre>\n<p>If you are running this on your own cloud server, make sure port 5000 is accessible. If you followed the optional\r\nsuggestion of using <code is:raw>ngrok</code>, this should be all set up simply by running <code is:raw>ngrok http 5000</code> on a separate terminal.</p>\n<p>To quickly test the integration, start a call to your Twilio number - this call will be forwarded to the phone number\r\nin the <code is:raw>Dial</code> section of your TwiML Bin, so you will need two phones (so feel free to grab a friend, or set up\r\na Google Voice account or something similar!).</p>\n<p>After the phone call has started, use a tool like <a href="https://github.com/vi/websocat#installation">websocat</a> to connect\r\nto <code is:raw>ws://localhost:5000/client</code>. Upon connecting, the server should output a list of the <code is:raw>callSid</code>s of ongoing calls\r\n(it should be a list of exactly one call at this point); reply to the server with one of these <code is:raw>callSid</code>s and watch\r\nthe Deepgram transcription responses roll in! You can start multiple clients and have them all subscribe to the\r\nsame <code is:raw>callSid</code> to see how a concurrent system could work.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1649269367/blog/2022/04/deepgram-twilio-streaming/assets/websocat_screenshot.png" alt="Using websocat to view the transcripts." style="max-width: 1623px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="further-development">Further Development</h2>\n<p>The Deepgram-Twilio integration design presented here is slightly opinionated, in the interest of getting\r\na reasonably complete demo up and running. You may want to factor in authentication, as the <code is:raw>/client</code> endpoint\r\nexplained here is completely unauthenticated. You also may want to find an alternate way of labelling calls\r\nto subscribe to - instead of grabbing <code is:raw>callSid</code>s, one could subscribe directly to Twilio numbers, but this\r\nwould require extra Twilio API integration to look up the status of calls to your Twilio numbers.</p>\n<p>Another clear next step would be to develop a proper client application. Programs like <code is:raw>websocat</code> are fantastic\r\nfor testing, but you will likely want to design a front-end application which handles selecting <code is:raw>callSid</code>s\r\nto subscribe to, parses and formats the Deepgram transcription response, and possibly other features.</p>\n<p>If you have any questions, please feel free to reach out on Twitter - we\u2019re <a href="https://twitter.com/DeepgramDevs">@DeepgramDevs</a>.</p>' };
const frontmatter = { "title": "Transcribing Twilio Voice Calls in Real-Time with Deepgram", "description": "In this tutorial, learn how to transcribe Twilio Voice calls with Deepgram with real-time speech-to-text.", "date": "2022-04-07T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1649267223/blog/2022/04/deepgram-twilio-streaming/Transcribing-Twilio-Calls-Real-Time-w-Deepgram%402x.jpg", "authors": ["nikola-whallon"], "category": "tutorial", "tags": ["twilio", "python"], "seo": { "title": "Transcribing Twilio Voice Calls in Real-Time with Deepgram", "description": "In this tutorial, learn how to transcribe Twilio Voice calls with Deepgram with real-time speech-to-text." }, "shorturls": { "share": "https://dpgr.am/650fd92", "twitter": "https://dpgr.am/6458d1e", "linkedin": "https://dpgr.am/273ef64", "reddit": "https://dpgr.am/2fc8f2d", "facebook": "https://dpgr.am/80b16d1" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661454061/blog/deepgram-twilio-streaming/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "pre-requisites", "text": "Pre-requisites" }, { "depth": 2, "slug": "setting-up-a-twiml-bin", "text": "Setting Up A TwiML Bin" }, { "depth": 2, "slug": "the-twilio-proxy-server", "text": "The Twilio Proxy Server" }, { "depth": 2, "slug": "running-the-server-and-testing-with-websocat", "text": "Running the Server and Testing with WebSocat" }, { "depth": 2, "slug": "further-development", "text": "Further Development" }], "source": "\nTwilio is a very popular voice platform, and Deepgram is a great automatic speech recognition (ASR) solution, so there\r\nis great value in integrating the two. This tutorial will guide you through building an integration that allows\r\nmultiple client subscribers to watch live transcripts from ongoing Twilio calls. The code for this tutorial\r\nis located [here](https://github.com/deepgram-devs/deepgram-twilio-streaming-python).\n\n## Pre-requisites\n\nYou will need:\n\n*   A [Twilio account](https://www.twilio.com/try-twilio) with a Twilio number (the free tier will work).\n*   A Deepgram API Key - [get an API Key here](https://console.deepgram.com/signup?jump=keys).\n*   *(Optional)* [ngrok](https://ngrok.com/) to let Twilio access a local server.\n\n## Setting Up A TwiML Bin\n\nWe need to tell Twilio to fork audio data from calls going to your Twilio number to the server we are going to write.\r\nThis is done via \"TwiML Bin\"s. In the Twilio Console, search for TwiML Bin, and click \"Create TwiML Bin.\"\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648782300/blog/2022/04/deepgram-twilio-streaming/assets/find_twiml_bin.png\" alt=\"Navigate to your TwiML Bins.\" style=\"max-width: 606px;display: block;margin-left: auto;margin-right: auto;\">\n\nGive the TwiML Bin a \"Friendly Name\" - something like \"Streaming\" or \"Deepgram Streaming,\" and then make the contents of the TwiML Bin the following:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Response>\r\n  <Start>\r\n    <Stream url=\"wss://INSERT_YOUR_SERVER_URL/twilio\" track=\"both_tracks\"/>\r\n  </Start>\r\n  <Say voice=\"woman\" language=\"en\">\"This call may be monitored or recorded for quality purposes.\"</Say>\r\n  <Dial>+11231231234</Dial>\r\n</Response>\n```\n\nReplace the number in the `Dial` section with the phone number you want incoming calls to be forwarded to (this should not be\r\nyour Twilio number, it should be the number of a real phone in your possession!). Then, where it says `INSERT_YOUR_SERVER_URL`\r\ntype in the URL where you will be running your server. Without having to setup an AWS or DigitalOcean server, you can use\r\n`ngrok` to expose a local server. To expose port 5000 on your computer, you can use ngrok as follows:\n\n```bash\nngrok http 5000\n```\n\n`ngrok` will then tell you the public URL which points to your `localhost:5000`. Your URL may\r\nend up looking something like: `c52e-71-212-124-133.ngrok.io`.\n\nNow, we need to connect this TwiML Bin to your Twilio phone number. Go to the \"Develop\" tab on the left side\r\nof the Twilio Console, navigate to `Phone Numbers -> Manage -> Active numbers`, and click on your Twilio number\r\nin the list. Then, under the field \"A Call Comes In,\" click the drop-down and select \"TwiML Bin\"; for the field\r\ndirectly next to this one, click the drop-down and select \"Streaming\" (or whatever your TwiML Bin's \"Friendly Name\" is).\r\nFinally, click \"Save\" at the bottom of the Twilio Console. Everything on Twilio's side should now be set up, and we\r\nare ready to move on to the Deepgram integration server!\n\n## The Twilio Proxy Server\n\nLet's take a look at the system we are building here:\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648783494/blog/2022/04/deepgram-twilio-streaming/assets/deepgram_twilio_diagram.png\" alt=\"The big picture.\" style=\"max-width: 2096px;display: block;margin-left: auto;margin-right: auto;\">\n\nWe have pairs of callers, inbound and outbound, and, for each call passing through Twilio's servers, Twilio is able to fork the audio from the call\r\nto our proxy server via websockets. Our server then has to do some light processing of that audio, forward it on to Deepgram, receive transcripts\r\nback from Deepgram, and forward those transcripts on to potentially multiple clients who are subscribed to watch the call's transcripts. So in order\r\nto view real-time transcripts in a client application, our backend server must maintain a minimum of three websockets connections - we can see how\r\nthis can get complicated, especially when dealing with many concurrent Twilio calls and subscribed clients!\n\nDownload the code from [this repository](https://github.com/deepgram-devs/deepgram-twilio-streaming-python). It contains a single file, `twilio.py`!\n\nLet's look at the code (make sure to replace `INSERT_YOUR_DEEPGRAM_API_KEY` with your Deepgram API Key):\n\n```python\nimport asyncio\r\nimport base64\r\nimport json\r\nimport sys\r\nimport websockets\r\nimport ssl\r\nfrom pydub import AudioSegment\r\n\r\nsubscribers = {}\r\n\r\ndef deepgram_connect():\r\n extra_headers = {\r\n  'Authorization': 'Token INSERT_YOUR_DEEPGRAM_API_KEY'\r\n }\r\n deepgram_ws = websockets.connect('wss://api.deepgram.com/v1/listen?encoding=mulaw&sample_rate=8000&channels=2&multichannel=true', extra_headers = extra_headers)\r\n\r\n return deepgram_ws\r\n\r\nasync def twilio_handler(twilio_ws):\r\n audio_queue = asyncio.Queue()\r\n callsid_queue = asyncio.Queue()\r\n\r\n async with deepgram_connect() as deepgram_ws:\r\n\r\n  async def deepgram_sender(deepgram_ws):\r\n   print('deepgram_sender started')\r\n   while True:\r\n    chunk = await audio_queue.get()\r\n    await deepgram_ws.send(chunk)\r\n\r\n  async def deepgram_receiver(deepgram_ws):\r\n   print('deepgram_receiver started')\r\n   # we will wait until the twilio ws connection figures out the callsid\r\n   # then we will initialize our subscribers list for this callsid\r\n   callsid = await callsid_queue.get()\r\n   subscribers[callsid] = []\r\n   # for each deepgram result received, forward it on to all\r\n   # queues subscribed to the twilio callsid\r\n   async for message in deepgram_ws:\r\n    for client in subscribers[callsid]:\r\n     client.put_nowait(message)\r\n\r\n   # once the twilio call is over, tell all subscribed clients to close\r\n   # and remove the subscriber list for this callsid\r\n   for client in subscribers[callsid]:\r\n    client.put_nowait('close')\r\n\r\n   del subscribers[callsid]\r\n\r\n  async def twilio_receiver(twilio_ws):\r\n   print('twilio_receiver started')\r\n   # twilio sends audio data as 160 byte messages containing 20ms of audio each\r\n   # we will buffer 20 twilio messages corresponding to 0.4 seconds of audio to improve throughput performance\r\n   BUFFER_SIZE = 20 * 160\r\n   # the algorithm to deal with mixing the two channels is somewhat complex\r\n   # here we implement an algorithm which fills in silence for channels if that channel is either\r\n   #   A) not currently streaming (e.g. the outbound channel when the inbound channel starts ringing it)\r\n   #   B) packets are dropped (this happens, and sometimes the timestamps which come back for subsequent packets are not aligned)\r\n   inbuffer = bytearray(b'')\r\n   outbuffer = bytearray(b'')\r\n   inbound_chunks_started = False\r\n   outbound_chunks_started = False\r\n   latest_inbound_timestamp = 0\r\n   latest_outbound_timestamp = 0\r\n   async for message in twilio_ws:\r\n    try:\r\n     data = json.loads(message)\r\n     if data['event'] == 'start':\r\n      start = data['start']\r\n      callsid = start['callSid']\r\n      callsid_queue.put_nowait(callsid)\r\n     if data['event'] == 'connected':\r\n      continue\r\n     if data['event'] == 'media':\r\n      media = data['media']\r\n      chunk = base64.b64decode(media['payload'])\r\n      if media['track'] == 'inbound':\r\n       # fills in silence if there have been dropped packets\r\n       if inbound_chunks_started:\r\n        if latest_inbound_timestamp + 20 < int(media['timestamp']):\r\n         bytes_to_fill = 8 * (int(media['timestamp']) - (latest_inbound_timestamp + 20))\r\n         # NOTE: 0xff is silence for mulaw audio\r\n         # and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)\r\n         inbuffer.extend(b'\\xff' * bytes_to_fill)\r\n       else:\r\n        # make it known that inbound chunks have started arriving\r\n        inbound_chunks_started = True\r\n        latest_inbound_timestamp = int(media['timestamp'])\r\n        # this basically sets the starting point for outbound timestamps\r\n        latest_outbound_timestamp = int(media['timestamp']) - 20\r\n       latest_inbound_timestamp = int(media['timestamp'])\r\n       # extend the inbound audio buffer with data\r\n       inbuffer.extend(chunk)\r\n      if media['track'] == 'outbound':\r\n       # make it known that outbound chunks have started arriving\r\n       outbound_chunked_started = True\r\n       # fills in silence if there have been dropped packets\r\n       if latest_outbound_timestamp + 20 < int(media['timestamp']):\r\n        bytes_to_fill = 8 * (int(media['timestamp']) - (latest_outbound_timestamp + 20))\r\n        # NOTE: 0xff is silence for mulaw audio\r\n        # and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)\r\n        outbuffer.extend(b'\\xff' * bytes_to_fill)\r\n       latest_outbound_timestamp = int(media['timestamp'])\r\n       # extend the outbound audio buffer with data\r\n       outbuffer.extend(chunk)\r\n     if data['event'] == 'stop':\r\n      break\r\n\r\n     # check if our buffer is ready to send to our audio_queue (and, thus, then to deepgram)\r\n     while len(inbuffer) >= BUFFER_SIZE and len(outbuffer) >= BUFFER_SIZE:\r\n      asinbound = AudioSegment(inbuffer[:BUFFER_SIZE], sample_width=1, frame_rate=8000, channels=1)\r\n      asoutbound = AudioSegment(outbuffer[:BUFFER_SIZE], sample_width=1, frame_rate=8000, channels=1)\r\n      mixed = AudioSegment.from_mono_audiosegments(asinbound, asoutbound)\r\n\r\n      # sending to deepgram via the audio_queue\r\n      audio_queue.put_nowait(mixed.raw_data)\r\n\r\n      # clearing buffers\r\n      inbuffer = inbuffer[BUFFER_SIZE:]\r\n      outbuffer = outbuffer[BUFFER_SIZE:]\r\n    except:\r\n     break\r\n\r\n   # the async for loop will end if the ws connection from twilio dies\r\n   # and if this happens, we should forward an empty byte to deepgram\r\n   # to signal deepgram to send back remaining messages before closing\r\n   audio_queue.put_nowait(b'')\r\n\r\n  await asyncio.wait([\r\n   asyncio.ensure_future(deepgram_sender(deepgram_ws)),\r\n   asyncio.ensure_future(deepgram_receiver(deepgram_ws)),\r\n   asyncio.ensure_future(twilio_receiver(twilio_ws))\r\n  ])\r\n\r\n  await twilio_ws.close()\r\n\r\nasync def client_handler(client_ws):\r\n client_queue = asyncio.Queue()\r\n\r\n # first tell the client all active calls\r\n await client_ws.send(json.dumps(list(subscribers.keys())))\r\n\r\n # then recieve from the client which call they would like to subscribe to\r\n # and add our client's queue to the subscriber list for that call\r\n try:\r\n  # you may want to parse a proper json input here\r\n  # instead of grabbing the entire message as the callsid verbatim\r\n  callsid = await client_ws.recv()\r\n  callsid = callsid.strip()\r\n  if callsid in subscribers:\r\n   subscribers[callsid].append(client_queue)\r\n  else:\r\n   await client_ws.close()\r\n except:\r\n  await client_ws.close()\r\n\r\n async def client_sender(client_ws):\r\n  while True:\r\n   message = await client_queue.get()\r\n   if message == 'close':\r\n    break\r\n   try:\r\n    await client_ws.send(message)\r\n   except:\r\n    # if there was an error, remove this client queue\r\n    subscribers[callsid].remove(client_queue)\r\n    break\r\n\r\n await asyncio.wait([\r\n  asyncio.ensure_future(client_sender(client_ws)),\r\n ])\r\n\r\n await client_ws.close()\r\n\r\nasync def router(websocket, path):\r\n if path == '/client':\r\n  print('client connection incoming')\r\n  await client_handler(websocket)\r\n elif path == '/twilio':\r\n  print('twilio connection incoming')\r\n  await twilio_handler(websocket)\r\n\r\ndef main():\r\n # use this if using ssl\r\n# ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\r\n# ssl_context.load_cert_chain('cert.pem', 'key.pem')\r\n# server = websockets.serve(router, '0.0.0.0', 443, ssl=ssl_context)\r\n\r\n # use this if not using ssl\r\n server = websockets.serve(router, 'localhost', 5000)\r\n\r\n asyncio.get_event_loop().run_until_complete(server)\r\n asyncio.get_event_loop().run_forever()\r\n\r\nif __name__ == '__main__':\r\n sys.exit(main() or 0)\n```\n\nThis server uses the Python `websocket` library to connect to Twilio, Deepgram, and client applications, and the `asyncio` library to handle\r\nconcurrent connections. The server has two routes: `/twilio` and `/client`. As we have configured in our TwiML Bin, Twilio will be connecting\r\nto and sending audio data to the `/twilio` endpoint, and we will use the `/client` endpoint for client applications which will watch the\r\nstreaming transcripts.\n\nThe server uses a dictionary, called `subscribers`, to handle concurrent connected clients. Specifically, `subscribers` is a dictionary\r\nwhose keys are Twilio `callSid`s which uniquely identify calls, and whose values are a list of queues for clients who are \"subscribed\"\r\nto those calls (i.e. watching for streaming transcripts from those calls).\n\nTo dive into the code, let's look at the `client_handler` function. When a client connects to the `/client` endpoint, the `client_handler`\r\nfunction will first send a websocket message to the client listing the `callSid`s of all currently streaming calls. The function then waits\r\nto receive a websocket message which it expects to be the `callSid` of the call that the client wants to view live transcripts for\r\n(and if the function does not receive a valid `callSid`, it will bail). Having received a valid `callSid`, the function then inserts\r\nthis client's queue into the `subscribers` dictionary and starts an async task which reads from this queue, sending transcription\r\nresults back to the client via websocket messages, or gracefully closing the websocket connection if the message \"close\" was received on the queue.\n\nNow let's jump into the more involved `twilio_handler` function. This function handles incoming websocket connections from Twilio,\r\nand begins by setting up a queue for audio data, and a queue to handle passing the incoming `callSid` between async tasks.\r\nIt then connects to Deepgram and sets up three async tasks: `deepgram_receiver`, `deepgram_sender`, and `twilio_receiver` (we will\r\nnever send websocket messages back to Twilio, hence no \"twilio\\_sender\" task).\n\nThe `twilio_receiver` task handles incoming [websocket messages](https://www.twilio.com/docs/voice/twiml/stream#websocket-messages-from-twilio) from Twilio.\r\nBefore Twilio sends audio data, it will send some metadata as part of a `start` event. One of these pieces of metadata is the `callSid`\r\nof the call, and we will pass that on to the `deepgram_receiver` task via a queue. Then, when Twilio starts streaming `media` (i.e. audio)\r\nevents, we will perform some logic to buffer and mix this audio. In particular, Twilio will stream audio in via separate `inbound`\r\nand `outbound` audio tracks; we must make sure we mix these two audio tracks together as correct stereo audio to pass on to Deepgram.\r\nSome issues arise if call packets are dropped from one of these tracks, and logic is implemented with ample comments to deal with this\r\nwithout having the two channels in the mixed stereo audio get out of sync. Finally, with correctly mixed audio buffers prepared,\r\n`twilio_receiver` will pass this audio on to the `deepgram_sender` task via a queue. The `deepgram_sender` task then simply passes\r\nthis audio on to Deepgram via the Deepgram websocket handle.\n\nFinally, we get to the `deepgram_receiver` task. In order to pass transcripts from Deepgram on to subscribed clients, we must first\r\nknow the `callSid` of the call, so the first thing `deepgram_receiver` does is wait to obtain this from the `twilio_receiver` via\r\na queue. Once the `callSid` is obtained, the `deepgram_receiver` is then able to forward on all transcription results from Deepgram\r\nto all clients subscribed to that `callSid`. It does this via another queue, which is handled by the async task defined in `client_handler`,\r\nand thus we come full circle.\n\n## Running the Server and Testing with WebSocat\n\nTo run the server, first `pip3 install` the `websockets`, `pydub`, and `asyncio` libraries, and then run:\n\n```bash\npython3 twilio.py\n```\n\nIf you are running this on your own cloud server, make sure port 5000 is accessible. If you followed the optional\r\nsuggestion of using `ngrok`, this should be all set up simply by running `ngrok http 5000` on a separate terminal.\n\nTo quickly test the integration, start a call to your Twilio number - this call will be forwarded to the phone number\r\nin the `Dial` section of your TwiML Bin, so you will need two phones (so feel free to grab a friend, or set up\r\na Google Voice account or something similar!).\n\nAfter the phone call has started, use a tool like [websocat](https://github.com/vi/websocat#installation) to connect\r\nto `ws://localhost:5000/client`. Upon connecting, the server should output a list of the `callSid`s of ongoing calls\r\n(it should be a list of exactly one call at this point); reply to the server with one of these `callSid`s and watch\r\nthe Deepgram transcription responses roll in! You can start multiple clients and have them all subscribe to the\r\nsame `callSid` to see how a concurrent system could work.\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1649269367/blog/2022/04/deepgram-twilio-streaming/assets/websocat_screenshot.png\" alt=\"Using websocat to view the transcripts.\" style=\"max-width: 1623px;display: block;margin-left: auto;margin-right: auto;\">\n\n## Further Development\n\nThe Deepgram-Twilio integration design presented here is slightly opinionated, in the interest of getting\r\na reasonably complete demo up and running. You may want to factor in authentication, as the `/client` endpoint\r\nexplained here is completely unauthenticated. You also may want to find an alternate way of labelling calls\r\nto subscribe to - instead of grabbing `callSid`s, one could subscribe directly to Twilio numbers, but this\r\nwould require extra Twilio API integration to look up the status of calls to your Twilio numbers.\n\nAnother clear next step would be to develop a proper client application. Programs like `websocat` are fantastic\r\nfor testing, but you will likely want to design a front-end application which handles selecting `callSid`s\r\nto subscribe to, parses and formats the Deepgram transcription response, and possibly other features.\n\nIf you have any questions, please feel free to reach out on Twitter - we're [@DeepgramDevs](https://twitter.com/DeepgramDevs).\n\n        ", "html": '<p>Twilio is a very popular voice platform, and Deepgram is a great automatic speech recognition (ASR) solution, so there\r\nis great value in integrating the two. This tutorial will guide you through building an integration that allows\r\nmultiple client subscribers to watch live transcripts from ongoing Twilio calls. The code for this tutorial\r\nis located <a href="https://github.com/deepgram-devs/deepgram-twilio-streaming-python">here</a>.</p>\n<h2 id="pre-requisites">Pre-requisites</h2>\n<p>You will need:</p>\n<ul>\n<li>A <a href="https://www.twilio.com/try-twilio">Twilio account</a> with a Twilio number (the free tier will work).</li>\n<li>A Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get an API Key here</a>.</li>\n<li><em>(Optional)</em> <a href="https://ngrok.com/">ngrok</a> to let Twilio access a local server.</li>\n</ul>\n<h2 id="setting-up-a-twiml-bin">Setting Up A TwiML Bin</h2>\n<p>We need to tell Twilio to fork audio data from calls going to your Twilio number to the server we are going to write.\r\nThis is done via \u201CTwiML Bin\u201Ds. In the Twilio Console, search for TwiML Bin, and click \u201CCreate TwiML Bin.\u201D</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648782300/blog/2022/04/deepgram-twilio-streaming/assets/find_twiml_bin.png" alt="Navigate to your TwiML Bins." style="max-width: 606px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Give the TwiML Bin a \u201CFriendly Name\u201D - something like \u201CStreaming\u201D or \u201CDeepgram Streaming,\u201D and then make the contents of the TwiML Bin the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;?</span><span style="color: #7EE787">xml</span><span style="color: #79C0FF"> version</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;1.0&quot;</span><span style="color: #79C0FF"> encoding</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;UTF-8&quot;</span><span style="color: #C9D1D9">?&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">Response</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Start</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">Stream</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">url</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;wss://INSERT_YOUR_SERVER_URL/twilio&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">track</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;both_tracks&quot;</span><span style="color: #C9D1D9">/&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">Start</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Say</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">voice</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;woman&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">language</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;en&quot;</span><span style="color: #C9D1D9">&gt;&quot;This call may be monitored or recorded for quality purposes.&quot;&lt;/</span><span style="color: #7EE787">Say</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Dial</span><span style="color: #C9D1D9">&gt;+11231231234&lt;/</span><span style="color: #7EE787">Dial</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">Response</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Replace the number in the <code is:raw>Dial</code> section with the phone number you want incoming calls to be forwarded to (this should not be\r\nyour Twilio number, it should be the number of a real phone in your possession!). Then, where it says <code is:raw>INSERT_YOUR_SERVER_URL</code>\r\ntype in the URL where you will be running your server. Without having to setup an AWS or DigitalOcean server, you can use\r\n<code is:raw>ngrok</code> to expose a local server. To expose port 5000 on your computer, you can use ngrok as follows:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">ngrok http 5000</span></span></code></pre>\n<p><code is:raw>ngrok</code> will then tell you the public URL which points to your <code is:raw>localhost:5000</code>. Your URL may\r\nend up looking something like: <code is:raw>c52e-71-212-124-133.ngrok.io</code>.</p>\n<p>Now, we need to connect this TwiML Bin to your Twilio phone number. Go to the \u201CDevelop\u201D tab on the left side\r\nof the Twilio Console, navigate to <code is:raw>Phone Numbers -&gt; Manage -&gt; Active numbers</code>, and click on your Twilio number\r\nin the list. Then, under the field \u201CA Call Comes In,\u201D click the drop-down and select \u201CTwiML Bin\u201D; for the field\r\ndirectly next to this one, click the drop-down and select \u201CStreaming\u201D (or whatever your TwiML Bin\u2019s \u201CFriendly Name\u201D is).\r\nFinally, click \u201CSave\u201D at the bottom of the Twilio Console. Everything on Twilio\u2019s side should now be set up, and we\r\nare ready to move on to the Deepgram integration server!</p>\n<h2 id="the-twilio-proxy-server">The Twilio Proxy Server</h2>\n<p>Let\u2019s take a look at the system we are building here:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648783494/blog/2022/04/deepgram-twilio-streaming/assets/deepgram_twilio_diagram.png" alt="The big picture." style="max-width: 2096px;display: block;margin-left: auto;margin-right: auto;" />\n<p>We have pairs of callers, inbound and outbound, and, for each call passing through Twilio\u2019s servers, Twilio is able to fork the audio from the call\r\nto our proxy server via websockets. Our server then has to do some light processing of that audio, forward it on to Deepgram, receive transcripts\r\nback from Deepgram, and forward those transcripts on to potentially multiple clients who are subscribed to watch the call\u2019s transcripts. So in order\r\nto view real-time transcripts in a client application, our backend server must maintain a minimum of three websockets connections - we can see how\r\nthis can get complicated, especially when dealing with many concurrent Twilio calls and subscribed clients!</p>\n<p>Download the code from <a href="https://github.com/deepgram-devs/deepgram-twilio-streaming-python">this repository</a>. It contains a single file, <code is:raw>twilio.py</code>!</p>\n<p>Let\u2019s look at the code (make sure to replace <code is:raw>INSERT_YOUR_DEEPGRAM_API_KEY</code> with your Deepgram API Key):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> base64</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> ssl</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> pydub </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> AudioSegment</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">subscribers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_connect</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9"> extra_headers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token INSERT_YOUR_DEEPGRAM_API_KEY&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9"> deepgram_ws </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> websockets.connect(</span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?encoding=mulaw&amp;sample_rate=8000&amp;channels=2&amp;multichannel=true&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">extra_headers</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> extra_headers)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> deepgram_ws</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">twilio_handler</span><span style="color: #C9D1D9">(twilio_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9"> audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"><span style="color: #C9D1D9"> callsid_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> deepgram_connect() </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> deepgram_ws:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_sender</span><span style="color: #C9D1D9">(deepgram_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;deepgram_sender started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    chunk </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram_ws.send(chunk)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_receiver</span><span style="color: #C9D1D9">(deepgram_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;deepgram_receiver started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># we will wait until the twilio ws connection figures out the callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># then we will initialize our subscribers list for this callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> callsid_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">   subscribers[callsid] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> []</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># for each deepgram result received, forward it on to all</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># queues subscribed to the twilio callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> deepgram_ws:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> client </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers[callsid]:</span></span>\n<span class="line"><span style="color: #C9D1D9">     client.put_nowait(message)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># once the twilio call is over, tell all subscribed clients to close</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># and remove the subscriber list for this callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> client </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers[callsid]:</span></span>\n<span class="line"><span style="color: #C9D1D9">    client.put_nowait(</span><span style="color: #A5D6FF">&#39;close&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">del</span><span style="color: #C9D1D9"> subscribers[callsid]</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">twilio_receiver</span><span style="color: #C9D1D9">(twilio_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;twilio_receiver started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># twilio sends audio data as 160 byte messages containing 20ms of audio each</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># we will buffer 20 twilio messages corresponding to 0.4 seconds of audio to improve throughput performance</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">160</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># the algorithm to deal with mixing the two channels is somewhat complex</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># here we implement an algorithm which fills in silence for channels if that channel is either</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">#   A) not currently streaming (e.g. the outbound channel when the inbound channel starts ringing it)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">#   B) packets are dropped (this happens, and sometimes the timestamps which come back for subsequent packets are not aligned)</span></span>\n<span class="line"><span style="color: #C9D1D9">   inbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">bytearray</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   outbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">bytearray</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   inbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>\n<span class="line"><span style="color: #C9D1D9">   outbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>\n<span class="line"><span style="color: #C9D1D9">   latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">   latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> twilio_ws:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">     data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(message)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> start[</span><span style="color: #A5D6FF">&#39;callSid&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      callsid_queue.put_nowait(callsid)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;connected&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">continue</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;media&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      media </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;media&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      chunk </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> base64.b64decode(media[</span><span style="color: #A5D6FF">&#39;payload&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> media[</span><span style="color: #A5D6FF">&#39;track&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;inbound&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># fills in silence if there have been dropped packets</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> inbound_chunks_started:</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> latest_inbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]):</span></span>\n<span class="line"><span style="color: #C9D1D9">         bytes_to_fill </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> (</span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> (latest_inbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"><span style="color: #C9D1D9">         </span><span style="color: #8B949E"># </span><span style="color: #FF7B72">NOTE</span><span style="color: #8B949E">: 0xff is silence for mulaw audio</span></span>\n<span class="line"><span style="color: #C9D1D9">         </span><span style="color: #8B949E"># and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)</span></span>\n<span class="line"><span style="color: #C9D1D9">         inbuffer.extend(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\xff</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> bytes_to_fill)</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># make it known that inbound chunks have started arriving</span></span>\n<span class="line"><span style="color: #C9D1D9">        inbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>\n<span class="line"><span style="color: #C9D1D9">        latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># this basically sets the starting point for outbound timestamps</span></span>\n<span class="line"><span style="color: #C9D1D9">        latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span></span>\n<span class="line"><span style="color: #C9D1D9">       latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># extend the inbound audio buffer with data</span></span>\n<span class="line"><span style="color: #C9D1D9">       inbuffer.extend(chunk)</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> media[</span><span style="color: #A5D6FF">&#39;track&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;outbound&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># make it known that outbound chunks have started arriving</span></span>\n<span class="line"><span style="color: #C9D1D9">       outbound_chunked_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># fills in silence if there have been dropped packets</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> latest_outbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]):</span></span>\n<span class="line"><span style="color: #C9D1D9">        bytes_to_fill </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> (</span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> (latest_outbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># </span><span style="color: #FF7B72">NOTE</span><span style="color: #8B949E">: 0xff is silence for mulaw audio</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)</span></span>\n<span class="line"><span style="color: #C9D1D9">        outbuffer.extend(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\xff</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> bytes_to_fill)</span></span>\n<span class="line"><span style="color: #C9D1D9">       latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># extend the outbound audio buffer with data</span></span>\n<span class="line"><span style="color: #C9D1D9">       outbuffer.extend(chunk)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stop&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #8B949E"># check if our buffer is ready to send to our audio_queue (and, thus, then to deepgram)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(inbuffer) </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(outbuffer) </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      asinbound </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment(inbuffer[:</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">sample_width</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">frame_rate</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">8000</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">channels</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">      asoutbound </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment(outbuffer[:</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">sample_width</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">frame_rate</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">8000</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">channels</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">      mixed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment.from_mono_audiosegments(asinbound, asoutbound)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E"># sending to deepgram via the audio_queue</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio_queue.put_nowait(mixed.raw_data)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E"># clearing buffers</span></span>\n<span class="line"><span style="color: #C9D1D9">      inbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> inbuffer[</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:]</span></span>\n<span class="line"><span style="color: #C9D1D9">      outbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> outbuffer[</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:]</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># the async for loop will end if the ws connection from twilio dies</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># and if this happens, we should forward an empty byte to deepgram</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># to signal deepgram to send back remaining messages before closing</span></span>\n<span class="line"><span style="color: #C9D1D9">   audio_queue.put_nowait(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(deepgram_sender(deepgram_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(deepgram_receiver(deepgram_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(twilio_receiver(twilio_ws))</span></span>\n<span class="line"><span style="color: #C9D1D9">  ])</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> twilio_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">client_handler</span><span style="color: #C9D1D9">(client_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9"> client_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># first tell the client all active calls</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.send(json.dumps(</span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(subscribers.keys())))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># then recieve from the client which call they would like to subscribe to</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># and add our client&#39;s queue to the subscriber list for that call</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E"># you may want to parse a proper json input here</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E"># instead of grabbing the entire message as the callsid verbatim</span></span>\n<span class="line"><span style="color: #C9D1D9">  callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.recv()</span></span>\n<span class="line"><span style="color: #C9D1D9">  callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callsid.strip()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> callsid </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers:</span></span>\n<span class="line"><span style="color: #C9D1D9">   subscribers[callsid].append(client_queue)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">client_sender</span><span style="color: #C9D1D9">(client_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">   message </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;close&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">break</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.send(message)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># if there was an error, remove this client queue</span></span>\n<span class="line"><span style="color: #C9D1D9">    subscribers[callsid].remove(client_queue)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>\n<span class="line"><span style="color: #C9D1D9">  asyncio.ensure_future(client_sender(client_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9"> ])</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">router</span><span style="color: #C9D1D9">(websocket, path):</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> path </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;/client&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;client connection incoming&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_handler(websocket)</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">elif</span><span style="color: #C9D1D9"> path </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;/twilio&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;twilio connection incoming&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> twilio_handler(websocket)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># use this if using ssl</span></span>\n<span class="line"><span style="color: #8B949E"># ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)</span></span>\n<span class="line"><span style="color: #8B949E"># ssl_context.load_cert_chain(&#39;cert.pem&#39;, &#39;key.pem&#39;)</span></span>\n<span class="line"><span style="color: #8B949E"># server = websockets.serve(router, &#39;0.0.0.0&#39;, 443, ssl=ssl_context)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># use this if not using ssl</span></span>\n<span class="line"><span style="color: #C9D1D9"> server </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> websockets.serve(router, </span><span style="color: #A5D6FF">&#39;localhost&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">5000</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> asyncio.get_event_loop().run_until_complete(server)</span></span>\n<span class="line"><span style="color: #C9D1D9"> asyncio.get_event_loop().run_forever()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9"> sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>This server uses the Python <code is:raw>websocket</code> library to connect to Twilio, Deepgram, and client applications, and the <code is:raw>asyncio</code> library to handle\r\nconcurrent connections. The server has two routes: <code is:raw>/twilio</code> and <code is:raw>/client</code>. As we have configured in our TwiML Bin, Twilio will be connecting\r\nto and sending audio data to the <code is:raw>/twilio</code> endpoint, and we will use the <code is:raw>/client</code> endpoint for client applications which will watch the\r\nstreaming transcripts.</p>\n<p>The server uses a dictionary, called <code is:raw>subscribers</code>, to handle concurrent connected clients. Specifically, <code is:raw>subscribers</code> is a dictionary\r\nwhose keys are Twilio <code is:raw>callSid</code>s which uniquely identify calls, and whose values are a list of queues for clients who are \u201Csubscribed\u201D\r\nto those calls (i.e. watching for streaming transcripts from those calls).</p>\n<p>To dive into the code, let\u2019s look at the <code is:raw>client_handler</code> function. When a client connects to the <code is:raw>/client</code> endpoint, the <code is:raw>client_handler</code>\r\nfunction will first send a websocket message to the client listing the <code is:raw>callSid</code>s of all currently streaming calls. The function then waits\r\nto receive a websocket message which it expects to be the <code is:raw>callSid</code> of the call that the client wants to view live transcripts for\r\n(and if the function does not receive a valid <code is:raw>callSid</code>, it will bail). Having received a valid <code is:raw>callSid</code>, the function then inserts\r\nthis client\u2019s queue into the <code is:raw>subscribers</code> dictionary and starts an async task which reads from this queue, sending transcription\r\nresults back to the client via websocket messages, or gracefully closing the websocket connection if the message \u201Cclose\u201D was received on the queue.</p>\n<p>Now let\u2019s jump into the more involved <code is:raw>twilio_handler</code> function. This function handles incoming websocket connections from Twilio,\r\nand begins by setting up a queue for audio data, and a queue to handle passing the incoming <code is:raw>callSid</code> between async tasks.\r\nIt then connects to Deepgram and sets up three async tasks: <code is:raw>deepgram_receiver</code>, <code is:raw>deepgram_sender</code>, and <code is:raw>twilio_receiver</code> (we will\r\nnever send websocket messages back to Twilio, hence no \u201Ctwilio_sender\u201D task).</p>\n<p>The <code is:raw>twilio_receiver</code> task handles incoming <a href="https://www.twilio.com/docs/voice/twiml/stream#websocket-messages-from-twilio">websocket messages</a> from Twilio.\r\nBefore Twilio sends audio data, it will send some metadata as part of a <code is:raw>start</code> event. One of these pieces of metadata is the <code is:raw>callSid</code>\r\nof the call, and we will pass that on to the <code is:raw>deepgram_receiver</code> task via a queue. Then, when Twilio starts streaming <code is:raw>media</code> (i.e. audio)\r\nevents, we will perform some logic to buffer and mix this audio. In particular, Twilio will stream audio in via separate <code is:raw>inbound</code>\r\nand <code is:raw>outbound</code> audio tracks; we must make sure we mix these two audio tracks together as correct stereo audio to pass on to Deepgram.\r\nSome issues arise if call packets are dropped from one of these tracks, and logic is implemented with ample comments to deal with this\r\nwithout having the two channels in the mixed stereo audio get out of sync. Finally, with correctly mixed audio buffers prepared,\r\n<code is:raw>twilio_receiver</code> will pass this audio on to the <code is:raw>deepgram_sender</code> task via a queue. The <code is:raw>deepgram_sender</code> task then simply passes\r\nthis audio on to Deepgram via the Deepgram websocket handle.</p>\n<p>Finally, we get to the <code is:raw>deepgram_receiver</code> task. In order to pass transcripts from Deepgram on to subscribed clients, we must first\r\nknow the <code is:raw>callSid</code> of the call, so the first thing <code is:raw>deepgram_receiver</code> does is wait to obtain this from the <code is:raw>twilio_receiver</code> via\r\na queue. Once the <code is:raw>callSid</code> is obtained, the <code is:raw>deepgram_receiver</code> is then able to forward on all transcription results from Deepgram\r\nto all clients subscribed to that <code is:raw>callSid</code>. It does this via another queue, which is handled by the async task defined in <code is:raw>client_handler</code>,\r\nand thus we come full circle.</p>\n<h2 id="running-the-server-and-testing-with-websocat">Running the Server and Testing with WebSocat</h2>\n<p>To run the server, first <code is:raw>pip3 install</code> the <code is:raw>websockets</code>, <code is:raw>pydub</code>, and <code is:raw>asyncio</code> libraries, and then run:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">python3 twilio.py</span></span></code></pre>\n<p>If you are running this on your own cloud server, make sure port 5000 is accessible. If you followed the optional\r\nsuggestion of using <code is:raw>ngrok</code>, this should be all set up simply by running <code is:raw>ngrok http 5000</code> on a separate terminal.</p>\n<p>To quickly test the integration, start a call to your Twilio number - this call will be forwarded to the phone number\r\nin the <code is:raw>Dial</code> section of your TwiML Bin, so you will need two phones (so feel free to grab a friend, or set up\r\na Google Voice account or something similar!).</p>\n<p>After the phone call has started, use a tool like <a href="https://github.com/vi/websocat#installation">websocat</a> to connect\r\nto <code is:raw>ws://localhost:5000/client</code>. Upon connecting, the server should output a list of the <code is:raw>callSid</code>s of ongoing calls\r\n(it should be a list of exactly one call at this point); reply to the server with one of these <code is:raw>callSid</code>s and watch\r\nthe Deepgram transcription responses roll in! You can start multiple clients and have them all subscribe to the\r\nsame <code is:raw>callSid</code> to see how a concurrent system could work.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1649269367/blog/2022/04/deepgram-twilio-streaming/assets/websocat_screenshot.png" alt="Using websocat to view the transcripts." style="max-width: 1623px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="further-development">Further Development</h2>\n<p>The Deepgram-Twilio integration design presented here is slightly opinionated, in the interest of getting\r\na reasonably complete demo up and running. You may want to factor in authentication, as the <code is:raw>/client</code> endpoint\r\nexplained here is completely unauthenticated. You also may want to find an alternate way of labelling calls\r\nto subscribe to - instead of grabbing <code is:raw>callSid</code>s, one could subscribe directly to Twilio numbers, but this\r\nwould require extra Twilio API integration to look up the status of calls to your Twilio numbers.</p>\n<p>Another clear next step would be to develop a proper client application. Programs like <code is:raw>websocat</code> are fantastic\r\nfor testing, but you will likely want to design a front-end application which handles selecting <code is:raw>callSid</code>s\r\nto subscribe to, parses and formats the Deepgram transcription response, and possibly other features.</p>\n<p>If you have any questions, please feel free to reach out on Twitter - we\u2019re <a href="https://twitter.com/DeepgramDevs">@DeepgramDevs</a>.</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/deepgram-twilio-streaming/index.md" };
function rawContent() {
  return "\nTwilio is a very popular voice platform, and Deepgram is a great automatic speech recognition (ASR) solution, so there\r\nis great value in integrating the two. This tutorial will guide you through building an integration that allows\r\nmultiple client subscribers to watch live transcripts from ongoing Twilio calls. The code for this tutorial\r\nis located [here](https://github.com/deepgram-devs/deepgram-twilio-streaming-python).\n\n## Pre-requisites\n\nYou will need:\n\n*   A [Twilio account](https://www.twilio.com/try-twilio) with a Twilio number (the free tier will work).\n*   A Deepgram API Key - [get an API Key here](https://console.deepgram.com/signup?jump=keys).\n*   *(Optional)* [ngrok](https://ngrok.com/) to let Twilio access a local server.\n\n## Setting Up A TwiML Bin\n\nWe need to tell Twilio to fork audio data from calls going to your Twilio number to the server we are going to write.\r\nThis is done via \"TwiML Bin\"s. In the Twilio Console, search for TwiML Bin, and click \"Create TwiML Bin.\"\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648782300/blog/2022/04/deepgram-twilio-streaming/assets/find_twiml_bin.png\" alt=\"Navigate to your TwiML Bins.\" style=\"max-width: 606px;display: block;margin-left: auto;margin-right: auto;\">\n\nGive the TwiML Bin a \"Friendly Name\" - something like \"Streaming\" or \"Deepgram Streaming,\" and then make the contents of the TwiML Bin the following:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Response>\r\n  <Start>\r\n    <Stream url=\"wss://INSERT_YOUR_SERVER_URL/twilio\" track=\"both_tracks\"/>\r\n  </Start>\r\n  <Say voice=\"woman\" language=\"en\">\"This call may be monitored or recorded for quality purposes.\"</Say>\r\n  <Dial>+11231231234</Dial>\r\n</Response>\n```\n\nReplace the number in the `Dial` section with the phone number you want incoming calls to be forwarded to (this should not be\r\nyour Twilio number, it should be the number of a real phone in your possession!). Then, where it says `INSERT_YOUR_SERVER_URL`\r\ntype in the URL where you will be running your server. Without having to setup an AWS or DigitalOcean server, you can use\r\n`ngrok` to expose a local server. To expose port 5000 on your computer, you can use ngrok as follows:\n\n```bash\nngrok http 5000\n```\n\n`ngrok` will then tell you the public URL which points to your `localhost:5000`. Your URL may\r\nend up looking something like: `c52e-71-212-124-133.ngrok.io`.\n\nNow, we need to connect this TwiML Bin to your Twilio phone number. Go to the \"Develop\" tab on the left side\r\nof the Twilio Console, navigate to `Phone Numbers -> Manage -> Active numbers`, and click on your Twilio number\r\nin the list. Then, under the field \"A Call Comes In,\" click the drop-down and select \"TwiML Bin\"; for the field\r\ndirectly next to this one, click the drop-down and select \"Streaming\" (or whatever your TwiML Bin's \"Friendly Name\" is).\r\nFinally, click \"Save\" at the bottom of the Twilio Console. Everything on Twilio's side should now be set up, and we\r\nare ready to move on to the Deepgram integration server!\n\n## The Twilio Proxy Server\n\nLet's take a look at the system we are building here:\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648783494/blog/2022/04/deepgram-twilio-streaming/assets/deepgram_twilio_diagram.png\" alt=\"The big picture.\" style=\"max-width: 2096px;display: block;margin-left: auto;margin-right: auto;\">\n\nWe have pairs of callers, inbound and outbound, and, for each call passing through Twilio's servers, Twilio is able to fork the audio from the call\r\nto our proxy server via websockets. Our server then has to do some light processing of that audio, forward it on to Deepgram, receive transcripts\r\nback from Deepgram, and forward those transcripts on to potentially multiple clients who are subscribed to watch the call's transcripts. So in order\r\nto view real-time transcripts in a client application, our backend server must maintain a minimum of three websockets connections - we can see how\r\nthis can get complicated, especially when dealing with many concurrent Twilio calls and subscribed clients!\n\nDownload the code from [this repository](https://github.com/deepgram-devs/deepgram-twilio-streaming-python). It contains a single file, `twilio.py`!\n\nLet's look at the code (make sure to replace `INSERT_YOUR_DEEPGRAM_API_KEY` with your Deepgram API Key):\n\n```python\nimport asyncio\r\nimport base64\r\nimport json\r\nimport sys\r\nimport websockets\r\nimport ssl\r\nfrom pydub import AudioSegment\r\n\r\nsubscribers = {}\r\n\r\ndef deepgram_connect():\r\n extra_headers = {\r\n  'Authorization': 'Token INSERT_YOUR_DEEPGRAM_API_KEY'\r\n }\r\n deepgram_ws = websockets.connect('wss://api.deepgram.com/v1/listen?encoding=mulaw&sample_rate=8000&channels=2&multichannel=true', extra_headers = extra_headers)\r\n\r\n return deepgram_ws\r\n\r\nasync def twilio_handler(twilio_ws):\r\n audio_queue = asyncio.Queue()\r\n callsid_queue = asyncio.Queue()\r\n\r\n async with deepgram_connect() as deepgram_ws:\r\n\r\n  async def deepgram_sender(deepgram_ws):\r\n   print('deepgram_sender started')\r\n   while True:\r\n    chunk = await audio_queue.get()\r\n    await deepgram_ws.send(chunk)\r\n\r\n  async def deepgram_receiver(deepgram_ws):\r\n   print('deepgram_receiver started')\r\n   # we will wait until the twilio ws connection figures out the callsid\r\n   # then we will initialize our subscribers list for this callsid\r\n   callsid = await callsid_queue.get()\r\n   subscribers[callsid] = []\r\n   # for each deepgram result received, forward it on to all\r\n   # queues subscribed to the twilio callsid\r\n   async for message in deepgram_ws:\r\n    for client in subscribers[callsid]:\r\n     client.put_nowait(message)\r\n\r\n   # once the twilio call is over, tell all subscribed clients to close\r\n   # and remove the subscriber list for this callsid\r\n   for client in subscribers[callsid]:\r\n    client.put_nowait('close')\r\n\r\n   del subscribers[callsid]\r\n\r\n  async def twilio_receiver(twilio_ws):\r\n   print('twilio_receiver started')\r\n   # twilio sends audio data as 160 byte messages containing 20ms of audio each\r\n   # we will buffer 20 twilio messages corresponding to 0.4 seconds of audio to improve throughput performance\r\n   BUFFER_SIZE = 20 * 160\r\n   # the algorithm to deal with mixing the two channels is somewhat complex\r\n   # here we implement an algorithm which fills in silence for channels if that channel is either\r\n   #   A) not currently streaming (e.g. the outbound channel when the inbound channel starts ringing it)\r\n   #   B) packets are dropped (this happens, and sometimes the timestamps which come back for subsequent packets are not aligned)\r\n   inbuffer = bytearray(b'')\r\n   outbuffer = bytearray(b'')\r\n   inbound_chunks_started = False\r\n   outbound_chunks_started = False\r\n   latest_inbound_timestamp = 0\r\n   latest_outbound_timestamp = 0\r\n   async for message in twilio_ws:\r\n    try:\r\n     data = json.loads(message)\r\n     if data['event'] == 'start':\r\n      start = data['start']\r\n      callsid = start['callSid']\r\n      callsid_queue.put_nowait(callsid)\r\n     if data['event'] == 'connected':\r\n      continue\r\n     if data['event'] == 'media':\r\n      media = data['media']\r\n      chunk = base64.b64decode(media['payload'])\r\n      if media['track'] == 'inbound':\r\n       # fills in silence if there have been dropped packets\r\n       if inbound_chunks_started:\r\n        if latest_inbound_timestamp + 20 < int(media['timestamp']):\r\n         bytes_to_fill = 8 * (int(media['timestamp']) - (latest_inbound_timestamp + 20))\r\n         # NOTE: 0xff is silence for mulaw audio\r\n         # and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)\r\n         inbuffer.extend(b'\\xff' * bytes_to_fill)\r\n       else:\r\n        # make it known that inbound chunks have started arriving\r\n        inbound_chunks_started = True\r\n        latest_inbound_timestamp = int(media['timestamp'])\r\n        # this basically sets the starting point for outbound timestamps\r\n        latest_outbound_timestamp = int(media['timestamp']) - 20\r\n       latest_inbound_timestamp = int(media['timestamp'])\r\n       # extend the inbound audio buffer with data\r\n       inbuffer.extend(chunk)\r\n      if media['track'] == 'outbound':\r\n       # make it known that outbound chunks have started arriving\r\n       outbound_chunked_started = True\r\n       # fills in silence if there have been dropped packets\r\n       if latest_outbound_timestamp + 20 < int(media['timestamp']):\r\n        bytes_to_fill = 8 * (int(media['timestamp']) - (latest_outbound_timestamp + 20))\r\n        # NOTE: 0xff is silence for mulaw audio\r\n        # and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)\r\n        outbuffer.extend(b'\\xff' * bytes_to_fill)\r\n       latest_outbound_timestamp = int(media['timestamp'])\r\n       # extend the outbound audio buffer with data\r\n       outbuffer.extend(chunk)\r\n     if data['event'] == 'stop':\r\n      break\r\n\r\n     # check if our buffer is ready to send to our audio_queue (and, thus, then to deepgram)\r\n     while len(inbuffer) >= BUFFER_SIZE and len(outbuffer) >= BUFFER_SIZE:\r\n      asinbound = AudioSegment(inbuffer[:BUFFER_SIZE], sample_width=1, frame_rate=8000, channels=1)\r\n      asoutbound = AudioSegment(outbuffer[:BUFFER_SIZE], sample_width=1, frame_rate=8000, channels=1)\r\n      mixed = AudioSegment.from_mono_audiosegments(asinbound, asoutbound)\r\n\r\n      # sending to deepgram via the audio_queue\r\n      audio_queue.put_nowait(mixed.raw_data)\r\n\r\n      # clearing buffers\r\n      inbuffer = inbuffer[BUFFER_SIZE:]\r\n      outbuffer = outbuffer[BUFFER_SIZE:]\r\n    except:\r\n     break\r\n\r\n   # the async for loop will end if the ws connection from twilio dies\r\n   # and if this happens, we should forward an empty byte to deepgram\r\n   # to signal deepgram to send back remaining messages before closing\r\n   audio_queue.put_nowait(b'')\r\n\r\n  await asyncio.wait([\r\n   asyncio.ensure_future(deepgram_sender(deepgram_ws)),\r\n   asyncio.ensure_future(deepgram_receiver(deepgram_ws)),\r\n   asyncio.ensure_future(twilio_receiver(twilio_ws))\r\n  ])\r\n\r\n  await twilio_ws.close()\r\n\r\nasync def client_handler(client_ws):\r\n client_queue = asyncio.Queue()\r\n\r\n # first tell the client all active calls\r\n await client_ws.send(json.dumps(list(subscribers.keys())))\r\n\r\n # then recieve from the client which call they would like to subscribe to\r\n # and add our client's queue to the subscriber list for that call\r\n try:\r\n  # you may want to parse a proper json input here\r\n  # instead of grabbing the entire message as the callsid verbatim\r\n  callsid = await client_ws.recv()\r\n  callsid = callsid.strip()\r\n  if callsid in subscribers:\r\n   subscribers[callsid].append(client_queue)\r\n  else:\r\n   await client_ws.close()\r\n except:\r\n  await client_ws.close()\r\n\r\n async def client_sender(client_ws):\r\n  while True:\r\n   message = await client_queue.get()\r\n   if message == 'close':\r\n    break\r\n   try:\r\n    await client_ws.send(message)\r\n   except:\r\n    # if there was an error, remove this client queue\r\n    subscribers[callsid].remove(client_queue)\r\n    break\r\n\r\n await asyncio.wait([\r\n  asyncio.ensure_future(client_sender(client_ws)),\r\n ])\r\n\r\n await client_ws.close()\r\n\r\nasync def router(websocket, path):\r\n if path == '/client':\r\n  print('client connection incoming')\r\n  await client_handler(websocket)\r\n elif path == '/twilio':\r\n  print('twilio connection incoming')\r\n  await twilio_handler(websocket)\r\n\r\ndef main():\r\n # use this if using ssl\r\n# ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\r\n# ssl_context.load_cert_chain('cert.pem', 'key.pem')\r\n# server = websockets.serve(router, '0.0.0.0', 443, ssl=ssl_context)\r\n\r\n # use this if not using ssl\r\n server = websockets.serve(router, 'localhost', 5000)\r\n\r\n asyncio.get_event_loop().run_until_complete(server)\r\n asyncio.get_event_loop().run_forever()\r\n\r\nif __name__ == '__main__':\r\n sys.exit(main() or 0)\n```\n\nThis server uses the Python `websocket` library to connect to Twilio, Deepgram, and client applications, and the `asyncio` library to handle\r\nconcurrent connections. The server has two routes: `/twilio` and `/client`. As we have configured in our TwiML Bin, Twilio will be connecting\r\nto and sending audio data to the `/twilio` endpoint, and we will use the `/client` endpoint for client applications which will watch the\r\nstreaming transcripts.\n\nThe server uses a dictionary, called `subscribers`, to handle concurrent connected clients. Specifically, `subscribers` is a dictionary\r\nwhose keys are Twilio `callSid`s which uniquely identify calls, and whose values are a list of queues for clients who are \"subscribed\"\r\nto those calls (i.e. watching for streaming transcripts from those calls).\n\nTo dive into the code, let's look at the `client_handler` function. When a client connects to the `/client` endpoint, the `client_handler`\r\nfunction will first send a websocket message to the client listing the `callSid`s of all currently streaming calls. The function then waits\r\nto receive a websocket message which it expects to be the `callSid` of the call that the client wants to view live transcripts for\r\n(and if the function does not receive a valid `callSid`, it will bail). Having received a valid `callSid`, the function then inserts\r\nthis client's queue into the `subscribers` dictionary and starts an async task which reads from this queue, sending transcription\r\nresults back to the client via websocket messages, or gracefully closing the websocket connection if the message \"close\" was received on the queue.\n\nNow let's jump into the more involved `twilio_handler` function. This function handles incoming websocket connections from Twilio,\r\nand begins by setting up a queue for audio data, and a queue to handle passing the incoming `callSid` between async tasks.\r\nIt then connects to Deepgram and sets up three async tasks: `deepgram_receiver`, `deepgram_sender`, and `twilio_receiver` (we will\r\nnever send websocket messages back to Twilio, hence no \"twilio\\_sender\" task).\n\nThe `twilio_receiver` task handles incoming [websocket messages](https://www.twilio.com/docs/voice/twiml/stream#websocket-messages-from-twilio) from Twilio.\r\nBefore Twilio sends audio data, it will send some metadata as part of a `start` event. One of these pieces of metadata is the `callSid`\r\nof the call, and we will pass that on to the `deepgram_receiver` task via a queue. Then, when Twilio starts streaming `media` (i.e. audio)\r\nevents, we will perform some logic to buffer and mix this audio. In particular, Twilio will stream audio in via separate `inbound`\r\nand `outbound` audio tracks; we must make sure we mix these two audio tracks together as correct stereo audio to pass on to Deepgram.\r\nSome issues arise if call packets are dropped from one of these tracks, and logic is implemented with ample comments to deal with this\r\nwithout having the two channels in the mixed stereo audio get out of sync. Finally, with correctly mixed audio buffers prepared,\r\n`twilio_receiver` will pass this audio on to the `deepgram_sender` task via a queue. The `deepgram_sender` task then simply passes\r\nthis audio on to Deepgram via the Deepgram websocket handle.\n\nFinally, we get to the `deepgram_receiver` task. In order to pass transcripts from Deepgram on to subscribed clients, we must first\r\nknow the `callSid` of the call, so the first thing `deepgram_receiver` does is wait to obtain this from the `twilio_receiver` via\r\na queue. Once the `callSid` is obtained, the `deepgram_receiver` is then able to forward on all transcription results from Deepgram\r\nto all clients subscribed to that `callSid`. It does this via another queue, which is handled by the async task defined in `client_handler`,\r\nand thus we come full circle.\n\n## Running the Server and Testing with WebSocat\n\nTo run the server, first `pip3 install` the `websockets`, `pydub`, and `asyncio` libraries, and then run:\n\n```bash\npython3 twilio.py\n```\n\nIf you are running this on your own cloud server, make sure port 5000 is accessible. If you followed the optional\r\nsuggestion of using `ngrok`, this should be all set up simply by running `ngrok http 5000` on a separate terminal.\n\nTo quickly test the integration, start a call to your Twilio number - this call will be forwarded to the phone number\r\nin the `Dial` section of your TwiML Bin, so you will need two phones (so feel free to grab a friend, or set up\r\na Google Voice account or something similar!).\n\nAfter the phone call has started, use a tool like [websocat](https://github.com/vi/websocat#installation) to connect\r\nto `ws://localhost:5000/client`. Upon connecting, the server should output a list of the `callSid`s of ongoing calls\r\n(it should be a list of exactly one call at this point); reply to the server with one of these `callSid`s and watch\r\nthe Deepgram transcription responses roll in! You can start multiple clients and have them all subscribe to the\r\nsame `callSid` to see how a concurrent system could work.\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1649269367/blog/2022/04/deepgram-twilio-streaming/assets/websocat_screenshot.png\" alt=\"Using websocat to view the transcripts.\" style=\"max-width: 1623px;display: block;margin-left: auto;margin-right: auto;\">\n\n## Further Development\n\nThe Deepgram-Twilio integration design presented here is slightly opinionated, in the interest of getting\r\na reasonably complete demo up and running. You may want to factor in authentication, as the `/client` endpoint\r\nexplained here is completely unauthenticated. You also may want to find an alternate way of labelling calls\r\nto subscribe to - instead of grabbing `callSid`s, one could subscribe directly to Twilio numbers, but this\r\nwould require extra Twilio API integration to look up the status of calls to your Twilio numbers.\n\nAnother clear next step would be to develop a proper client application. Programs like `websocat` are fantastic\r\nfor testing, but you will likely want to design a front-end application which handles selecting `callSid`s\r\nto subscribe to, parses and formats the Deepgram transcription response, and possibly other features.\n\nIf you have any questions, please feel free to reach out on Twitter - we're [@DeepgramDevs](https://twitter.com/DeepgramDevs).\n\n        ";
}
function compiledContent() {
  return '<p>Twilio is a very popular voice platform, and Deepgram is a great automatic speech recognition (ASR) solution, so there\r\nis great value in integrating the two. This tutorial will guide you through building an integration that allows\r\nmultiple client subscribers to watch live transcripts from ongoing Twilio calls. The code for this tutorial\r\nis located <a href="https://github.com/deepgram-devs/deepgram-twilio-streaming-python">here</a>.</p>\n<h2 id="pre-requisites">Pre-requisites</h2>\n<p>You will need:</p>\n<ul>\n<li>A <a href="https://www.twilio.com/try-twilio">Twilio account</a> with a Twilio number (the free tier will work).</li>\n<li>A Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get an API Key here</a>.</li>\n<li><em>(Optional)</em> <a href="https://ngrok.com/">ngrok</a> to let Twilio access a local server.</li>\n</ul>\n<h2 id="setting-up-a-twiml-bin">Setting Up A TwiML Bin</h2>\n<p>We need to tell Twilio to fork audio data from calls going to your Twilio number to the server we are going to write.\r\nThis is done via \u201CTwiML Bin\u201Ds. In the Twilio Console, search for TwiML Bin, and click \u201CCreate TwiML Bin.\u201D</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648782300/blog/2022/04/deepgram-twilio-streaming/assets/find_twiml_bin.png" alt="Navigate to your TwiML Bins." style="max-width: 606px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Give the TwiML Bin a \u201CFriendly Name\u201D - something like \u201CStreaming\u201D or \u201CDeepgram Streaming,\u201D and then make the contents of the TwiML Bin the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;?</span><span style="color: #7EE787">xml</span><span style="color: #79C0FF"> version</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;1.0&quot;</span><span style="color: #79C0FF"> encoding</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;UTF-8&quot;</span><span style="color: #C9D1D9">?&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">Response</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Start</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">Stream</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">url</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;wss://INSERT_YOUR_SERVER_URL/twilio&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">track</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;both_tracks&quot;</span><span style="color: #C9D1D9">/&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">Start</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Say</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">voice</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;woman&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">language</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;en&quot;</span><span style="color: #C9D1D9">&gt;&quot;This call may be monitored or recorded for quality purposes.&quot;&lt;/</span><span style="color: #7EE787">Say</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Dial</span><span style="color: #C9D1D9">&gt;+11231231234&lt;/</span><span style="color: #7EE787">Dial</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">Response</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Replace the number in the <code is:raw>Dial</code> section with the phone number you want incoming calls to be forwarded to (this should not be\r\nyour Twilio number, it should be the number of a real phone in your possession!). Then, where it says <code is:raw>INSERT_YOUR_SERVER_URL</code>\r\ntype in the URL where you will be running your server. Without having to setup an AWS or DigitalOcean server, you can use\r\n<code is:raw>ngrok</code> to expose a local server. To expose port 5000 on your computer, you can use ngrok as follows:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">ngrok http 5000</span></span></code></pre>\n<p><code is:raw>ngrok</code> will then tell you the public URL which points to your <code is:raw>localhost:5000</code>. Your URL may\r\nend up looking something like: <code is:raw>c52e-71-212-124-133.ngrok.io</code>.</p>\n<p>Now, we need to connect this TwiML Bin to your Twilio phone number. Go to the \u201CDevelop\u201D tab on the left side\r\nof the Twilio Console, navigate to <code is:raw>Phone Numbers -&gt; Manage -&gt; Active numbers</code>, and click on your Twilio number\r\nin the list. Then, under the field \u201CA Call Comes In,\u201D click the drop-down and select \u201CTwiML Bin\u201D; for the field\r\ndirectly next to this one, click the drop-down and select \u201CStreaming\u201D (or whatever your TwiML Bin\u2019s \u201CFriendly Name\u201D is).\r\nFinally, click \u201CSave\u201D at the bottom of the Twilio Console. Everything on Twilio\u2019s side should now be set up, and we\r\nare ready to move on to the Deepgram integration server!</p>\n<h2 id="the-twilio-proxy-server">The Twilio Proxy Server</h2>\n<p>Let\u2019s take a look at the system we are building here:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648783494/blog/2022/04/deepgram-twilio-streaming/assets/deepgram_twilio_diagram.png" alt="The big picture." style="max-width: 2096px;display: block;margin-left: auto;margin-right: auto;" />\n<p>We have pairs of callers, inbound and outbound, and, for each call passing through Twilio\u2019s servers, Twilio is able to fork the audio from the call\r\nto our proxy server via websockets. Our server then has to do some light processing of that audio, forward it on to Deepgram, receive transcripts\r\nback from Deepgram, and forward those transcripts on to potentially multiple clients who are subscribed to watch the call\u2019s transcripts. So in order\r\nto view real-time transcripts in a client application, our backend server must maintain a minimum of three websockets connections - we can see how\r\nthis can get complicated, especially when dealing with many concurrent Twilio calls and subscribed clients!</p>\n<p>Download the code from <a href="https://github.com/deepgram-devs/deepgram-twilio-streaming-python">this repository</a>. It contains a single file, <code is:raw>twilio.py</code>!</p>\n<p>Let\u2019s look at the code (make sure to replace <code is:raw>INSERT_YOUR_DEEPGRAM_API_KEY</code> with your Deepgram API Key):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> base64</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> ssl</span></span>\n<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> pydub </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> AudioSegment</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">subscribers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_connect</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9"> extra_headers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token INSERT_YOUR_DEEPGRAM_API_KEY&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9"> deepgram_ws </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> websockets.connect(</span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?encoding=mulaw&amp;sample_rate=8000&amp;channels=2&amp;multichannel=true&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">extra_headers</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> extra_headers)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> deepgram_ws</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">twilio_handler</span><span style="color: #C9D1D9">(twilio_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9"> audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"><span style="color: #C9D1D9"> callsid_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> deepgram_connect() </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> deepgram_ws:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_sender</span><span style="color: #C9D1D9">(deepgram_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;deepgram_sender started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    chunk </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram_ws.send(chunk)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_receiver</span><span style="color: #C9D1D9">(deepgram_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;deepgram_receiver started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># we will wait until the twilio ws connection figures out the callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># then we will initialize our subscribers list for this callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> callsid_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">   subscribers[callsid] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> []</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># for each deepgram result received, forward it on to all</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># queues subscribed to the twilio callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> deepgram_ws:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> client </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers[callsid]:</span></span>\n<span class="line"><span style="color: #C9D1D9">     client.put_nowait(message)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># once the twilio call is over, tell all subscribed clients to close</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># and remove the subscriber list for this callsid</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> client </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers[callsid]:</span></span>\n<span class="line"><span style="color: #C9D1D9">    client.put_nowait(</span><span style="color: #A5D6FF">&#39;close&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">del</span><span style="color: #C9D1D9"> subscribers[callsid]</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">twilio_receiver</span><span style="color: #C9D1D9">(twilio_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;twilio_receiver started&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># twilio sends audio data as 160 byte messages containing 20ms of audio each</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># we will buffer 20 twilio messages corresponding to 0.4 seconds of audio to improve throughput performance</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">160</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># the algorithm to deal with mixing the two channels is somewhat complex</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># here we implement an algorithm which fills in silence for channels if that channel is either</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">#   A) not currently streaming (e.g. the outbound channel when the inbound channel starts ringing it)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">#   B) packets are dropped (this happens, and sometimes the timestamps which come back for subsequent packets are not aligned)</span></span>\n<span class="line"><span style="color: #C9D1D9">   inbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">bytearray</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   outbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">bytearray</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">   inbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>\n<span class="line"><span style="color: #C9D1D9">   outbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>\n<span class="line"><span style="color: #C9D1D9">   latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">   latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> twilio_ws:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">     data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(message)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> start[</span><span style="color: #A5D6FF">&#39;callSid&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      callsid_queue.put_nowait(callsid)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;connected&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">continue</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;media&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      media </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;media&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      chunk </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> base64.b64decode(media[</span><span style="color: #A5D6FF">&#39;payload&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> media[</span><span style="color: #A5D6FF">&#39;track&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;inbound&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># fills in silence if there have been dropped packets</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> inbound_chunks_started:</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> latest_inbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]):</span></span>\n<span class="line"><span style="color: #C9D1D9">         bytes_to_fill </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> (</span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> (latest_inbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"><span style="color: #C9D1D9">         </span><span style="color: #8B949E"># </span><span style="color: #FF7B72">NOTE</span><span style="color: #8B949E">: 0xff is silence for mulaw audio</span></span>\n<span class="line"><span style="color: #C9D1D9">         </span><span style="color: #8B949E"># and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)</span></span>\n<span class="line"><span style="color: #C9D1D9">         inbuffer.extend(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\xff</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> bytes_to_fill)</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># make it known that inbound chunks have started arriving</span></span>\n<span class="line"><span style="color: #C9D1D9">        inbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>\n<span class="line"><span style="color: #C9D1D9">        latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># this basically sets the starting point for outbound timestamps</span></span>\n<span class="line"><span style="color: #C9D1D9">        latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span></span>\n<span class="line"><span style="color: #C9D1D9">       latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># extend the inbound audio buffer with data</span></span>\n<span class="line"><span style="color: #C9D1D9">       inbuffer.extend(chunk)</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> media[</span><span style="color: #A5D6FF">&#39;track&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;outbound&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># make it known that outbound chunks have started arriving</span></span>\n<span class="line"><span style="color: #C9D1D9">       outbound_chunked_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># fills in silence if there have been dropped packets</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> latest_outbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]):</span></span>\n<span class="line"><span style="color: #C9D1D9">        bytes_to_fill </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> (</span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> (latest_outbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># </span><span style="color: #FF7B72">NOTE</span><span style="color: #8B949E">: 0xff is silence for mulaw audio</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)</span></span>\n<span class="line"><span style="color: #C9D1D9">        outbuffer.extend(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\xff</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> bytes_to_fill)</span></span>\n<span class="line"><span style="color: #C9D1D9">       latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>\n<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># extend the outbound audio buffer with data</span></span>\n<span class="line"><span style="color: #C9D1D9">       outbuffer.extend(chunk)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stop&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #8B949E"># check if our buffer is ready to send to our audio_queue (and, thus, then to deepgram)</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(inbuffer) </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(outbuffer) </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">      asinbound </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment(inbuffer[:</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">sample_width</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">frame_rate</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">8000</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">channels</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">      asoutbound </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment(outbuffer[:</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">sample_width</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">frame_rate</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">8000</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">channels</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">      mixed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment.from_mono_audiosegments(asinbound, asoutbound)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E"># sending to deepgram via the audio_queue</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio_queue.put_nowait(mixed.raw_data)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E"># clearing buffers</span></span>\n<span class="line"><span style="color: #C9D1D9">      inbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> inbuffer[</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:]</span></span>\n<span class="line"><span style="color: #C9D1D9">      outbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> outbuffer[</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:]</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># the async for loop will end if the ws connection from twilio dies</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># and if this happens, we should forward an empty byte to deepgram</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># to signal deepgram to send back remaining messages before closing</span></span>\n<span class="line"><span style="color: #C9D1D9">   audio_queue.put_nowait(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(deepgram_sender(deepgram_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(deepgram_receiver(deepgram_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(twilio_receiver(twilio_ws))</span></span>\n<span class="line"><span style="color: #C9D1D9">  ])</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> twilio_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">client_handler</span><span style="color: #C9D1D9">(client_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9"> client_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># first tell the client all active calls</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.send(json.dumps(</span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(subscribers.keys())))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># then recieve from the client which call they would like to subscribe to</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># and add our client&#39;s queue to the subscriber list for that call</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E"># you may want to parse a proper json input here</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E"># instead of grabbing the entire message as the callsid verbatim</span></span>\n<span class="line"><span style="color: #C9D1D9">  callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.recv()</span></span>\n<span class="line"><span style="color: #C9D1D9">  callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callsid.strip()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> callsid </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers:</span></span>\n<span class="line"><span style="color: #C9D1D9">   subscribers[callsid].append(client_queue)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">client_sender</span><span style="color: #C9D1D9">(client_ws):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">   message </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_queue.get()</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;close&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">break</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.send(message)</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># if there was an error, remove this client queue</span></span>\n<span class="line"><span style="color: #C9D1D9">    subscribers[callsid].remove(client_queue)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">break</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>\n<span class="line"><span style="color: #C9D1D9">  asyncio.ensure_future(client_sender(client_ws)),</span></span>\n<span class="line"><span style="color: #C9D1D9"> ])</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">router</span><span style="color: #C9D1D9">(websocket, path):</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> path </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;/client&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;client connection incoming&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_handler(websocket)</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">elif</span><span style="color: #C9D1D9"> path </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;/twilio&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;twilio connection incoming&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> twilio_handler(websocket)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># use this if using ssl</span></span>\n<span class="line"><span style="color: #8B949E"># ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)</span></span>\n<span class="line"><span style="color: #8B949E"># ssl_context.load_cert_chain(&#39;cert.pem&#39;, &#39;key.pem&#39;)</span></span>\n<span class="line"><span style="color: #8B949E"># server = websockets.serve(router, &#39;0.0.0.0&#39;, 443, ssl=ssl_context)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># use this if not using ssl</span></span>\n<span class="line"><span style="color: #C9D1D9"> server </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> websockets.serve(router, </span><span style="color: #A5D6FF">&#39;localhost&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">5000</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9"> asyncio.get_event_loop().run_until_complete(server)</span></span>\n<span class="line"><span style="color: #C9D1D9"> asyncio.get_event_loop().run_forever()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9"> sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>This server uses the Python <code is:raw>websocket</code> library to connect to Twilio, Deepgram, and client applications, and the <code is:raw>asyncio</code> library to handle\r\nconcurrent connections. The server has two routes: <code is:raw>/twilio</code> and <code is:raw>/client</code>. As we have configured in our TwiML Bin, Twilio will be connecting\r\nto and sending audio data to the <code is:raw>/twilio</code> endpoint, and we will use the <code is:raw>/client</code> endpoint for client applications which will watch the\r\nstreaming transcripts.</p>\n<p>The server uses a dictionary, called <code is:raw>subscribers</code>, to handle concurrent connected clients. Specifically, <code is:raw>subscribers</code> is a dictionary\r\nwhose keys are Twilio <code is:raw>callSid</code>s which uniquely identify calls, and whose values are a list of queues for clients who are \u201Csubscribed\u201D\r\nto those calls (i.e. watching for streaming transcripts from those calls).</p>\n<p>To dive into the code, let\u2019s look at the <code is:raw>client_handler</code> function. When a client connects to the <code is:raw>/client</code> endpoint, the <code is:raw>client_handler</code>\r\nfunction will first send a websocket message to the client listing the <code is:raw>callSid</code>s of all currently streaming calls. The function then waits\r\nto receive a websocket message which it expects to be the <code is:raw>callSid</code> of the call that the client wants to view live transcripts for\r\n(and if the function does not receive a valid <code is:raw>callSid</code>, it will bail). Having received a valid <code is:raw>callSid</code>, the function then inserts\r\nthis client\u2019s queue into the <code is:raw>subscribers</code> dictionary and starts an async task which reads from this queue, sending transcription\r\nresults back to the client via websocket messages, or gracefully closing the websocket connection if the message \u201Cclose\u201D was received on the queue.</p>\n<p>Now let\u2019s jump into the more involved <code is:raw>twilio_handler</code> function. This function handles incoming websocket connections from Twilio,\r\nand begins by setting up a queue for audio data, and a queue to handle passing the incoming <code is:raw>callSid</code> between async tasks.\r\nIt then connects to Deepgram and sets up three async tasks: <code is:raw>deepgram_receiver</code>, <code is:raw>deepgram_sender</code>, and <code is:raw>twilio_receiver</code> (we will\r\nnever send websocket messages back to Twilio, hence no \u201Ctwilio_sender\u201D task).</p>\n<p>The <code is:raw>twilio_receiver</code> task handles incoming <a href="https://www.twilio.com/docs/voice/twiml/stream#websocket-messages-from-twilio">websocket messages</a> from Twilio.\r\nBefore Twilio sends audio data, it will send some metadata as part of a <code is:raw>start</code> event. One of these pieces of metadata is the <code is:raw>callSid</code>\r\nof the call, and we will pass that on to the <code is:raw>deepgram_receiver</code> task via a queue. Then, when Twilio starts streaming <code is:raw>media</code> (i.e. audio)\r\nevents, we will perform some logic to buffer and mix this audio. In particular, Twilio will stream audio in via separate <code is:raw>inbound</code>\r\nand <code is:raw>outbound</code> audio tracks; we must make sure we mix these two audio tracks together as correct stereo audio to pass on to Deepgram.\r\nSome issues arise if call packets are dropped from one of these tracks, and logic is implemented with ample comments to deal with this\r\nwithout having the two channels in the mixed stereo audio get out of sync. Finally, with correctly mixed audio buffers prepared,\r\n<code is:raw>twilio_receiver</code> will pass this audio on to the <code is:raw>deepgram_sender</code> task via a queue. The <code is:raw>deepgram_sender</code> task then simply passes\r\nthis audio on to Deepgram via the Deepgram websocket handle.</p>\n<p>Finally, we get to the <code is:raw>deepgram_receiver</code> task. In order to pass transcripts from Deepgram on to subscribed clients, we must first\r\nknow the <code is:raw>callSid</code> of the call, so the first thing <code is:raw>deepgram_receiver</code> does is wait to obtain this from the <code is:raw>twilio_receiver</code> via\r\na queue. Once the <code is:raw>callSid</code> is obtained, the <code is:raw>deepgram_receiver</code> is then able to forward on all transcription results from Deepgram\r\nto all clients subscribed to that <code is:raw>callSid</code>. It does this via another queue, which is handled by the async task defined in <code is:raw>client_handler</code>,\r\nand thus we come full circle.</p>\n<h2 id="running-the-server-and-testing-with-websocat">Running the Server and Testing with WebSocat</h2>\n<p>To run the server, first <code is:raw>pip3 install</code> the <code is:raw>websockets</code>, <code is:raw>pydub</code>, and <code is:raw>asyncio</code> libraries, and then run:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">python3 twilio.py</span></span></code></pre>\n<p>If you are running this on your own cloud server, make sure port 5000 is accessible. If you followed the optional\r\nsuggestion of using <code is:raw>ngrok</code>, this should be all set up simply by running <code is:raw>ngrok http 5000</code> on a separate terminal.</p>\n<p>To quickly test the integration, start a call to your Twilio number - this call will be forwarded to the phone number\r\nin the <code is:raw>Dial</code> section of your TwiML Bin, so you will need two phones (so feel free to grab a friend, or set up\r\na Google Voice account or something similar!).</p>\n<p>After the phone call has started, use a tool like <a href="https://github.com/vi/websocat#installation">websocat</a> to connect\r\nto <code is:raw>ws://localhost:5000/client</code>. Upon connecting, the server should output a list of the <code is:raw>callSid</code>s of ongoing calls\r\n(it should be a list of exactly one call at this point); reply to the server with one of these <code is:raw>callSid</code>s and watch\r\nthe Deepgram transcription responses roll in! You can start multiple clients and have them all subscribe to the\r\nsame <code is:raw>callSid</code> to see how a concurrent system could work.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1649269367/blog/2022/04/deepgram-twilio-streaming/assets/websocat_screenshot.png" alt="Using websocat to view the transcripts." style="max-width: 1623px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="further-development">Further Development</h2>\n<p>The Deepgram-Twilio integration design presented here is slightly opinionated, in the interest of getting\r\na reasonably complete demo up and running. You may want to factor in authentication, as the <code is:raw>/client</code> endpoint\r\nexplained here is completely unauthenticated. You also may want to find an alternate way of labelling calls\r\nto subscribe to - instead of grabbing <code is:raw>callSid</code>s, one could subscribe directly to Twilio numbers, but this\r\nwould require extra Twilio API integration to look up the status of calls to your Twilio numbers.</p>\n<p>Another clear next step would be to develop a proper client application. Programs like <code is:raw>websocat</code> are fantastic\r\nfor testing, but you will likely want to design a front-end application which handles selecting <code is:raw>callSid</code>s\r\nto subscribe to, parses and formats the Deepgram transcription response, and possibly other features.</p>\n<p>If you have any questions, please feel free to reach out on Twitter - we\u2019re <a href="https://twitter.com/DeepgramDevs">@DeepgramDevs</a>.</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/deepgram-twilio-streaming/index.md", "", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>Twilio is a very popular voice platform, and Deepgram is a great automatic speech recognition (ASR) solution, so there
is great value in integrating the two. This tutorial will guide you through building an integration that allows
multiple client subscribers to watch live transcripts from ongoing Twilio calls. The code for this tutorial
is located <a href="https://github.com/deepgram-devs/deepgram-twilio-streaming-python">here</a>.</p>
<h2 id="pre-requisites">Pre-requisites</h2>
<p>You will need:</p>
<ul>
<li>A <a href="https://www.twilio.com/try-twilio">Twilio account</a> with a Twilio number (the free tier will work).</li>
<li>A Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get an API Key here</a>.</li>
<li><em>(Optional)</em> <a href="https://ngrok.com/">ngrok</a> to let Twilio access a local server.</li>
</ul>
<h2 id="setting-up-a-twiml-bin">Setting Up A TwiML Bin</h2>
<p>We need to tell Twilio to fork audio data from calls going to your Twilio number to the server we are going to write.
This is done via TwiML Bins. In the Twilio Console, search for TwiML Bin, and click Create TwiML Bin.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1648782300/blog/2022/04/deepgram-twilio-streaming/assets/find_twiml_bin.png" alt="Navigate to your TwiML Bins." style="max-width: 606px;display: block;margin-left: auto;margin-right: auto;">
<p>Give the TwiML Bin a Friendly Name - something like Streaming or Deepgram Streaming, and then make the contents of the TwiML Bin the following:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;?</span><span style="color: #7EE787">xml</span><span style="color: #79C0FF"> version</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;1.0&quot;</span><span style="color: #79C0FF"> encoding</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;UTF-8&quot;</span><span style="color: #C9D1D9">?&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">Response</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Start</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">Stream</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">url</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;wss://INSERT_YOUR_SERVER_URL/twilio&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">track</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;both_tracks&quot;</span><span style="color: #C9D1D9">/&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">Start</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Say</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">voice</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;woman&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">language</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;en&quot;</span><span style="color: #C9D1D9">&gt;&quot;This call may be monitored or recorded for quality purposes.&quot;&lt;/</span><span style="color: #7EE787">Say</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">Dial</span><span style="color: #C9D1D9">&gt;+11231231234&lt;/</span><span style="color: #7EE787">Dial</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">Response</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>Replace the number in the <code>Dial</code> section with the phone number you want incoming calls to be forwarded to (this should not be
your Twilio number, it should be the number of a real phone in your possession!). Then, where it says <code>INSERT_YOUR_SERVER_URL</code>
type in the URL where you will be running your server. Without having to setup an AWS or DigitalOcean server, you can use
<code>ngrok</code> to expose a local server. To expose port 5000 on your computer, you can use ngrok as follows:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">ngrok http 5000</span></span></code></pre>
<p><code>ngrok</code> will then tell you the public URL which points to your <code>localhost:5000</code>. Your URL may
end up looking something like: <code>c52e-71-212-124-133.ngrok.io</code>.</p>
<p>Now, we need to connect this TwiML Bin to your Twilio phone number. Go to the Develop tab on the left side
of the Twilio Console, navigate to <code>Phone Numbers -&gt; Manage -&gt; Active numbers</code>, and click on your Twilio number
in the list. Then, under the field A Call Comes In, click the drop-down and select TwiML Bin; for the field
directly next to this one, click the drop-down and select Streaming (or whatever your TwiML Bins Friendly Name is).
Finally, click Save at the bottom of the Twilio Console. Everything on Twilios side should now be set up, and we
are ready to move on to the Deepgram integration server!</p>
<h2 id="the-twilio-proxy-server">The Twilio Proxy Server</h2>
<p>Lets take a look at the system we are building here:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1648783494/blog/2022/04/deepgram-twilio-streaming/assets/deepgram_twilio_diagram.png" alt="The big picture." style="max-width: 2096px;display: block;margin-left: auto;margin-right: auto;">
<p>We have pairs of callers, inbound and outbound, and, for each call passing through Twilios servers, Twilio is able to fork the audio from the call
to our proxy server via websockets. Our server then has to do some light processing of that audio, forward it on to Deepgram, receive transcripts
back from Deepgram, and forward those transcripts on to potentially multiple clients who are subscribed to watch the calls transcripts. So in order
to view real-time transcripts in a client application, our backend server must maintain a minimum of three websockets connections - we can see how
this can get complicated, especially when dealing with many concurrent Twilio calls and subscribed clients!</p>
<p>Download the code from <a href="https://github.com/deepgram-devs/deepgram-twilio-streaming-python">this repository</a>. It contains a single file, <code>twilio.py</code>!</p>
<p>Lets look at the code (make sure to replace <code>INSERT_YOUR_DEEPGRAM_API_KEY</code> with your Deepgram API Key):</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> base64</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> ssl</span></span>
<span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> pydub </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> AudioSegment</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">subscribers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_connect</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9"> extra_headers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token INSERT_YOUR_DEEPGRAM_API_KEY&#39;</span></span>
<span class="line"><span style="color: #C9D1D9"> }</span></span>
<span class="line"><span style="color: #C9D1D9"> deepgram_ws </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> websockets.connect(</span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?encoding=mulaw&amp;sample_rate=8000&amp;channels=2&amp;multichannel=true&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">extra_headers</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> extra_headers)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> deepgram_ws</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">twilio_handler</span><span style="color: #C9D1D9">(twilio_ws):</span></span>
<span class="line"><span style="color: #C9D1D9"> audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"><span style="color: #C9D1D9"> callsid_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> deepgram_connect() </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> deepgram_ws:</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_sender</span><span style="color: #C9D1D9">(deepgram_ws):</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;deepgram_sender started&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    chunk </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> deepgram_ws.send(chunk)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">deepgram_receiver</span><span style="color: #C9D1D9">(deepgram_ws):</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;deepgram_receiver started&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># we will wait until the twilio ws connection figures out the callsid</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># then we will initialize our subscribers list for this callsid</span></span>
<span class="line"><span style="color: #C9D1D9">   callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> callsid_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">   subscribers[callsid] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> []</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># for each deepgram result received, forward it on to all</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># queues subscribed to the twilio callsid</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> deepgram_ws:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> client </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers[callsid]:</span></span>
<span class="line"><span style="color: #C9D1D9">     client.put_nowait(message)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># once the twilio call is over, tell all subscribed clients to close</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># and remove the subscriber list for this callsid</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> client </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers[callsid]:</span></span>
<span class="line"><span style="color: #C9D1D9">    client.put_nowait(</span><span style="color: #A5D6FF">&#39;close&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">del</span><span style="color: #C9D1D9"> subscribers[callsid]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">twilio_receiver</span><span style="color: #C9D1D9">(twilio_ws):</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;twilio_receiver started&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># twilio sends audio data as 160 byte messages containing 20ms of audio each</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># we will buffer 20 twilio messages corresponding to 0.4 seconds of audio to improve throughput performance</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">160</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># the algorithm to deal with mixing the two channels is somewhat complex</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># here we implement an algorithm which fills in silence for channels if that channel is either</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">#   A) not currently streaming (e.g. the outbound channel when the inbound channel starts ringing it)</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">#   B) packets are dropped (this happens, and sometimes the timestamps which come back for subsequent packets are not aligned)</span></span>
<span class="line"><span style="color: #C9D1D9">   inbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">bytearray</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">   outbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">bytearray</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">   inbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"><span style="color: #C9D1D9">   outbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"><span style="color: #C9D1D9">   latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>
<span class="line"><span style="color: #C9D1D9">   latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> twilio_ws:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">     data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(message)</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">      start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">      callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> start[</span><span style="color: #A5D6FF">&#39;callSid&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">      callsid_queue.put_nowait(callsid)</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;connected&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">continue</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;media&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">      media </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;media&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">      chunk </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> base64.b64decode(media[</span><span style="color: #A5D6FF">&#39;payload&#39;</span><span style="color: #C9D1D9">])</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> media[</span><span style="color: #A5D6FF">&#39;track&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;inbound&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># fills in silence if there have been dropped packets</span></span>
<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> inbound_chunks_started:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> latest_inbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]):</span></span>
<span class="line"><span style="color: #C9D1D9">         bytes_to_fill </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> (</span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> (latest_inbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">))</span></span>
<span class="line"><span style="color: #C9D1D9">         </span><span style="color: #8B949E"># </span><span style="color: #FF7B72">NOTE</span><span style="color: #8B949E">: 0xff is silence for mulaw audio</span></span>
<span class="line"><span style="color: #C9D1D9">         </span><span style="color: #8B949E"># and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)</span></span>
<span class="line"><span style="color: #C9D1D9">         inbuffer.extend(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\xff</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> bytes_to_fill)</span></span>
<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># make it known that inbound chunks have started arriving</span></span>
<span class="line"><span style="color: #C9D1D9">        inbound_chunks_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"><span style="color: #C9D1D9">        latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># this basically sets the starting point for outbound timestamps</span></span>
<span class="line"><span style="color: #C9D1D9">        latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span></span>
<span class="line"><span style="color: #C9D1D9">       latest_inbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>
<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># extend the inbound audio buffer with data</span></span>
<span class="line"><span style="color: #C9D1D9">       inbuffer.extend(chunk)</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> media[</span><span style="color: #A5D6FF">&#39;track&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;outbound&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># make it known that outbound chunks have started arriving</span></span>
<span class="line"><span style="color: #C9D1D9">       outbound_chunked_started </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># fills in silence if there have been dropped packets</span></span>
<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> latest_outbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]):</span></span>
<span class="line"><span style="color: #C9D1D9">        bytes_to_fill </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> (</span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> (latest_outbound_timestamp </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">))</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># </span><span style="color: #FF7B72">NOTE</span><span style="color: #8B949E">: 0xff is silence for mulaw audio</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E"># and there are 8 bytes per ms of data for our format (8 bit, 8000 Hz)</span></span>
<span class="line"><span style="color: #C9D1D9">        outbuffer.extend(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\xff</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> bytes_to_fill)</span></span>
<span class="line"><span style="color: #C9D1D9">       latest_outbound_timestamp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(media[</span><span style="color: #A5D6FF">&#39;timestamp&#39;</span><span style="color: #C9D1D9">])</span></span>
<span class="line"><span style="color: #C9D1D9">       </span><span style="color: #8B949E"># extend the outbound audio buffer with data</span></span>
<span class="line"><span style="color: #C9D1D9">       outbuffer.extend(chunk)</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;event&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;stop&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">break</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #8B949E"># check if our buffer is ready to send to our audio_queue (and, thus, then to deepgram)</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(inbuffer) </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(outbuffer) </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">      asinbound </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment(inbuffer[:</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">sample_width</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">frame_rate</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">8000</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">channels</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">      asoutbound </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment(outbuffer[:</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">sample_width</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">frame_rate</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">8000</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">channels</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">      mixed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> AudioSegment.from_mono_audiosegments(asinbound, asoutbound)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E"># sending to deepgram via the audio_queue</span></span>
<span class="line"><span style="color: #C9D1D9">      audio_queue.put_nowait(mixed.raw_data)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E"># clearing buffers</span></span>
<span class="line"><span style="color: #C9D1D9">      inbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> inbuffer[</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:]</span></span>
<span class="line"><span style="color: #C9D1D9">      outbuffer </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> outbuffer[</span><span style="color: #79C0FF">BUFFER_SIZE</span><span style="color: #C9D1D9">:]</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #FF7B72">break</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># the async for loop will end if the ws connection from twilio dies</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># and if this happens, we should forward an empty byte to deepgram</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E"># to signal deepgram to send back remaining messages before closing</span></span>
<span class="line"><span style="color: #C9D1D9">   audio_queue.put_nowait(</span><span style="color: #FF7B72">b</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(deepgram_sender(deepgram_ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(deepgram_receiver(deepgram_ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">   asyncio.ensure_future(twilio_receiver(twilio_ws))</span></span>
<span class="line"><span style="color: #C9D1D9">  ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> twilio_ws.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">client_handler</span><span style="color: #C9D1D9">(client_ws):</span></span>
<span class="line"><span style="color: #C9D1D9"> client_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># first tell the client all active calls</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.send(json.dumps(</span><span style="color: #79C0FF">list</span><span style="color: #C9D1D9">(subscribers.keys())))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># then recieve from the client which call they would like to subscribe to</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># and add our client&#39;s queue to the subscriber list for that call</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E"># you may want to parse a proper json input here</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E"># instead of grabbing the entire message as the callsid verbatim</span></span>
<span class="line"><span style="color: #C9D1D9">  callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.recv()</span></span>
<span class="line"><span style="color: #C9D1D9">  callsid </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callsid.strip()</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> callsid </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> subscribers:</span></span>
<span class="line"><span style="color: #C9D1D9">   subscribers[callsid].append(client_queue)</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">client_sender</span><span style="color: #C9D1D9">(client_ws):</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">   message </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;close&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">break</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.send(message)</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># if there was an error, remove this client queue</span></span>
<span class="line"><span style="color: #C9D1D9">    subscribers[callsid].remove(client_queue)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">break</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">  asyncio.ensure_future(client_sender(client_ws)),</span></span>
<span class="line"><span style="color: #C9D1D9"> ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_ws.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">router</span><span style="color: #C9D1D9">(websocket, path):</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> path </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;/client&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;client connection incoming&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> client_handler(websocket)</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">elif</span><span style="color: #C9D1D9"> path </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;/twilio&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;twilio connection incoming&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> twilio_handler(websocket)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># use this if using ssl</span></span>
<span class="line"><span style="color: #8B949E"># ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)</span></span>
<span class="line"><span style="color: #8B949E"># ssl_context.load_cert_chain(&#39;cert.pem&#39;, &#39;key.pem&#39;)</span></span>
<span class="line"><span style="color: #8B949E"># server = websockets.serve(router, &#39;0.0.0.0&#39;, 443, ssl=ssl_context)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #8B949E"># use this if not using ssl</span></span>
<span class="line"><span style="color: #C9D1D9"> server </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> websockets.serve(router, </span><span style="color: #A5D6FF">&#39;localhost&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">5000</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9"> asyncio.get_event_loop().run_until_complete(server)</span></span>
<span class="line"><span style="color: #C9D1D9"> asyncio.get_event_loop().run_forever()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9"> sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>This server uses the Python <code>websocket</code> library to connect to Twilio, Deepgram, and client applications, and the <code>asyncio</code> library to handle
concurrent connections. The server has two routes: <code>/twilio</code> and <code>/client</code>. As we have configured in our TwiML Bin, Twilio will be connecting
to and sending audio data to the <code>/twilio</code> endpoint, and we will use the <code>/client</code> endpoint for client applications which will watch the
streaming transcripts.</p>
<p>The server uses a dictionary, called <code>subscribers</code>, to handle concurrent connected clients. Specifically, <code>subscribers</code> is a dictionary
whose keys are Twilio <code>callSid</code>s which uniquely identify calls, and whose values are a list of queues for clients who are subscribed
to those calls (i.e. watching for streaming transcripts from those calls).</p>
<p>To dive into the code, lets look at the <code>client_handler</code> function. When a client connects to the <code>/client</code> endpoint, the <code>client_handler</code>
function will first send a websocket message to the client listing the <code>callSid</code>s of all currently streaming calls. The function then waits
to receive a websocket message which it expects to be the <code>callSid</code> of the call that the client wants to view live transcripts for
(and if the function does not receive a valid <code>callSid</code>, it will bail). Having received a valid <code>callSid</code>, the function then inserts
this clients queue into the <code>subscribers</code> dictionary and starts an async task which reads from this queue, sending transcription
results back to the client via websocket messages, or gracefully closing the websocket connection if the message close was received on the queue.</p>
<p>Now lets jump into the more involved <code>twilio_handler</code> function. This function handles incoming websocket connections from Twilio,
and begins by setting up a queue for audio data, and a queue to handle passing the incoming <code>callSid</code> between async tasks.
It then connects to Deepgram and sets up three async tasks: <code>deepgram_receiver</code>, <code>deepgram_sender</code>, and <code>twilio_receiver</code> (we will
never send websocket messages back to Twilio, hence no twilio_sender task).</p>
<p>The <code>twilio_receiver</code> task handles incoming <a href="https://www.twilio.com/docs/voice/twiml/stream#websocket-messages-from-twilio">websocket messages</a> from Twilio.
Before Twilio sends audio data, it will send some metadata as part of a <code>start</code> event. One of these pieces of metadata is the <code>callSid</code>
of the call, and we will pass that on to the <code>deepgram_receiver</code> task via a queue. Then, when Twilio starts streaming <code>media</code> (i.e. audio)
events, we will perform some logic to buffer and mix this audio. In particular, Twilio will stream audio in via separate <code>inbound</code>
and <code>outbound</code> audio tracks; we must make sure we mix these two audio tracks together as correct stereo audio to pass on to Deepgram.
Some issues arise if call packets are dropped from one of these tracks, and logic is implemented with ample comments to deal with this
without having the two channels in the mixed stereo audio get out of sync. Finally, with correctly mixed audio buffers prepared,
<code>twilio_receiver</code> will pass this audio on to the <code>deepgram_sender</code> task via a queue. The <code>deepgram_sender</code> task then simply passes
this audio on to Deepgram via the Deepgram websocket handle.</p>
<p>Finally, we get to the <code>deepgram_receiver</code> task. In order to pass transcripts from Deepgram on to subscribed clients, we must first
know the <code>callSid</code> of the call, so the first thing <code>deepgram_receiver</code> does is wait to obtain this from the <code>twilio_receiver</code> via
a queue. Once the <code>callSid</code> is obtained, the <code>deepgram_receiver</code> is then able to forward on all transcription results from Deepgram
to all clients subscribed to that <code>callSid</code>. It does this via another queue, which is handled by the async task defined in <code>client_handler</code>,
and thus we come full circle.</p>
<h2 id="running-the-server-and-testing-with-websocat">Running the Server and Testing with WebSocat</h2>
<p>To run the server, first <code>pip3 install</code> the <code>websockets</code>, <code>pydub</code>, and <code>asyncio</code> libraries, and then run:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">python3 twilio.py</span></span></code></pre>
<p>If you are running this on your own cloud server, make sure port 5000 is accessible. If you followed the optional
suggestion of using <code>ngrok</code>, this should be all set up simply by running <code>ngrok http 5000</code> on a separate terminal.</p>
<p>To quickly test the integration, start a call to your Twilio number - this call will be forwarded to the phone number
in the <code>Dial</code> section of your TwiML Bin, so you will need two phones (so feel free to grab a friend, or set up
a Google Voice account or something similar!).</p>
<p>After the phone call has started, use a tool like <a href="https://github.com/vi/websocat#installation">websocat</a> to connect
to <code>ws://localhost:5000/client</code>. Upon connecting, the server should output a list of the <code>callSid</code>s of ongoing calls
(it should be a list of exactly one call at this point); reply to the server with one of these <code>callSid</code>s and watch
the Deepgram transcription responses roll in! You can start multiple clients and have them all subscribe to the
same <code>callSid</code> to see how a concurrent system could work.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1649269367/blog/2022/04/deepgram-twilio-streaming/assets/websocat_screenshot.png" alt="Using websocat to view the transcripts." style="max-width: 1623px;display: block;margin-left: auto;margin-right: auto;">
<h2 id="further-development">Further Development</h2>
<p>The Deepgram-Twilio integration design presented here is slightly opinionated, in the interest of getting
a reasonably complete demo up and running. You may want to factor in authentication, as the <code>/client</code> endpoint
explained here is completely unauthenticated. You also may want to find an alternate way of labelling calls
to subscribe to - instead of grabbing <code>callSid</code>s, one could subscribe directly to Twilio numbers, but this
would require extra Twilio API integration to look up the status of calls to your Twilio numbers.</p>
<p>Another clear next step would be to develop a proper client application. Programs like <code>websocat</code> are fantastic
for testing, but you will likely want to design a front-end application which handles selecting <code>callSid</code>s
to subscribe to, parses and formats the Deepgram transcription response, and possibly other features.</p>
<p>If you have any questions, please feel free to reach out on Twitter - were <a href="https://twitter.com/DeepgramDevs">@DeepgramDevs</a>.</p>`;
});

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
