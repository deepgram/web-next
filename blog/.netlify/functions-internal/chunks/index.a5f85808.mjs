import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           *//* empty css                           *//* empty css                          */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [], "source": "\nHow do you know when someone is finished talking? Before I started working at Deepgram, I hadn\u2019t thought about this question much. When having conversations in person, us humans can use all sorts of contextual cues, body language, and societal norms to figure out when someone has finished their thought and we can jump in with our own opinion. But as we\u2019ve all seen over Zoom during the last few years, figuring out when someone is done talking is a lot harder to do virtually. It\u2019s even harder when the listener isn\u2019t human at all\u2014and is a machine learning model transcribing speech!\n\nBusiness problems that need speech-to-text often also need an understanding of when a speaker has completed their thought. One common use case for this is building conversational AI bots that need to respond to a user\u2019s queries. The bot needs to be careful both to not to cut the user off, and to respond in a timely enough manner that the conversation feels \u201Creal-time\u201D.\n\nDeepgram\u2019s real-time speech-to-text service provides two main mechanisms that can help build a conversational flow. One is interim results, and the other is endpointing. Together, the two can give you information about when a speaker has finished talking, and when your system should respond.\n\n[Interim results](https://developers.deepgram.com/documentation/features/interim-results/), which are disabled by default, are sent back every few seconds. These messages, marked with `is_final=false`,  indicate that Deepgram is still gathering more audio and the transcription results may change as additional context is given. Once Deepgram has collected enough audio to make the best possible prediction, it will finalize the prediction and send back a transcript marked with `is_final=true`.\n\n[Endpointing](https://developers.deepgram.com/documentation/features/endpointing/), which is enabled by default, is an algorithm that detects the end of speech. When endpointing triggers, Deepgram immediately sends back a message. These messages will be marked with `speech_final=true` to indicate an endpoint was detected and `is_final=true `to indicate the transcription is finalized.\n\nThe simplest way to determine when someone is done talking is based on silence. Endpointing can give you almost immediate feedback when silence is detected, which may be useful for applications that prioritize quick processing of results. Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound when Deepgram detects an endpoint.\n\nTo run the code, install beepy using `pip install beepy`. Then save the following code as `endpointing.py`. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:\n\n`python endpointing.py  -k 'YOUR_DG_API_KEY'`\n\n```python\nimport pyaudio\nimport asyncio\nimport sys\nimport websockets\nimport time\nimport json\nimport argparse\nimport beepy\n\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 8000\n\naudio_queue = asyncio.Queue()\n\ndef callback(input_data, frame_count, time_info, status_flag):\n    audio_queue.put_nowait(input_data)\n    return (input_data, pyaudio.paContinue)\n\nasync def run(key):\n    extra_headers={\n        'Authorization': 'Token {}'.format(key)\n    }\n    async with websockets.connect('wss://api.deepgram.com/v1/listen?endpointing=true&encoding=linear16&sample_rate=16000&channels=1&interim_results=false', extra_headers = extra_headers) as ws:\n        async def microphone():\n            audio = pyaudio.PyAudio()\n            stream = audio.open(\n                format = FORMAT,\n                channels = CHANNELS,\n                rate = RATE,\n                input = True,\n                frames_per_buffer = CHUNK,\n                stream_callback = callback\n            )\n\n            stream.start_stream()\n\n            while stream.is_active():\n                await asyncio.sleep(0.1)\n\n            stream.stop_stream()\n            stream.close()\n\n        async def sender(ws):\n            try:\n                while True:\n                    data = await audio_queue.get()\n                    await ws.send(data)\n            except Exception as e:\n                print('Error while sending: '.format(str(e)))\n                raise\n\n        async def receiver(ws):\n            transcript = ''\n            async for msg in ws:\n                msg = json.loads(msg)\n\n                if len(msg['channel']['alternatives'][0]['transcript']) > 0:\n                    if len(transcript):\n                        transcript += ' '\n                    transcript += msg['channel']['alternatives'][0]['transcript']\n                    print(transcript, end = '\\r')\n\n                    if msg['speech_final']:\n                        print(transcript)\n                        beepy.beep(sound=1)\n                        transcript = ''\n\n        await asyncio.wait([\n            asyncio.ensure_future(microphone()),\n            asyncio.ensure_future(sender(ws)),\n            asyncio.ensure_future(receiver(ws))\n        ])\n\ndef parse_args():\n    \"\"\" Parses the command-line arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Submits data to the real-time streaming endpoint.')\n    parser.add_argument('-k', '--key', required=True, help='YOUR_DEEPGRAM_API_KEY (authorization)')\n    return parser.parse_args()\n\ndef main():\n    args = parse_args()\n\n    asyncio.get_event_loop().run_until_complete(run(args.key))\n\nif __name__ == '__main__':\n    sys.exit(main() or 0)\n```\n\nAs you may notice when using `endpointing.py`, Deepgram will detect that you have finished speaking as soon as possible, meaning that in a conversational flow, this logic can easily cut you off mid-sentence every time you make even a minor pause. Rather than responding immediately, many applications will want to wait for a few seconds after a speaker finishes talking. This can be especially effective in conversational AI, where users may be speaking for long durations and occasionally pause mid-thought\u2014waiting a few seconds to respond may result in a more natural conversational flow. A combination of endpointing and interim results can be used to determine when a desired duration of silence has passed.\n\nHere\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound after the number of seconds defined in a configurable `SILENCE_INTERVAL` has passed. (The default is 2.0, but this can be specified when running the script.)\n\nTo run the code, install beepy using `pip install beepy`. Then save the following code as `silence_interval.py`. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:\n\n`python silence_interval.py  -k 'YOUR_DG_API_KEY' [-s SILENCE_INTERVAL_SECONDS_FLOAT]`\n\n```python\nimport pyaudio\nimport asyncio\nimport sys\nimport websockets\nimport json\nimport beepy\nimport shutil\nimport argparse\n\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 8000\n\nterminal_size = shutil.get_terminal_size()\n\naudio_queue = asyncio.Queue()\n\ndef callback(input_data, frame_count, time_info, status_flag):\n    audio_queue.put_nowait(input_data)\n    return (input_data, pyaudio.paContinue)\n\nasync def run(key, silence_interval):\n    async with websockets.connect(\n        'wss://api.deepgram.com/v1/listen?endpointing=true&interim_results=true&encoding=linear16&sample_rate=16000&channels=1',\n        extra_headers={\n            'Authorization': 'Token {}'.format(key)\n        }\n    ) as ws:\n        async def microphone():\n            audio = pyaudio.PyAudio()\n            stream = audio.open(\n                format = FORMAT,\n                channels = CHANNELS,\n                rate = RATE,\n                input = True,\n                frames_per_buffer = CHUNK,\n                stream_callback = callback\n            )\n\n            stream.start_stream()\n\n            while stream.is_active():\n                await asyncio.sleep(0.1)\n\n            stream.stop_stream()\n            stream.close()\n\n        async def sender(ws):\n            try:\n                while True:\n                    data = await audio_queue.get()\n                    await ws.send(data)\n            except Exception as e:\n                print('Error while sending: '.format(str(e)))\n                raise\n\n        async def receiver(ws):\n            transcript = ''\n            last_word_end = 0.0\n            should_beep = False\n\n            async for message in ws:\n                message = json.loads(message)\n\n                transcript_cursor = message['start'] + message['duration']\n\n                # if there are any words in the message\n                if len(message['channel']['alternatives'][0]['words']) > 0:\n                    # handle transcript printing for final messages\n                    if message['is_final']:\n                        if len(transcript):\n                            transcript += ' '\n                        transcript += message['channel']['alternatives'][0]['transcript']\n                        print(transcript)\n                        # overwrite the line regardless of length\n                        # https://stackoverflow.com/a/47170056\n                        print('\\033[{}A'.format(len(transcript) // int(terminal_size.columns) + 1), end='')\n\n                    # if the last word in a previous message is silence_interval seconds\n                    # older than the first word in this message (and if that last word hasn't already triggered a beep)\n                    current_word_begin = message['channel']['alternatives'][0]['words'][0]['start']\n                    if current_word_begin - last_word_end >= silence_interval and last_word_end != 0.0:\n                        should_beep = True\n\n                    last_word_end = message['channel']['alternatives'][0]['words'][-1]['end']\n                else:\n                    # if there were no words in this message, check if the the last word\n                    # in a previous message is silence_interval or more seconds older\n                    # than the timestamp at the end of this message (if that last word hasn't already triggered a beep)\n                    if transcript_cursor - last_word_end >= silence_interval and last_word_end != 0.0:\n                        last_word_end = 0.0\n                        should_beep = True\n\n                if should_beep:\n                    beepy.beep(sound=1)\n                    should_beep = False\n                    # we set/mark last_word_end to 0.0 to indicate that this last word has already triggered a beep\n                    last_word_end = 0.0\n                    transcript = ''\n                    print('')\n\n        await asyncio.wait([\n            asyncio.ensure_future(microphone()),\n            asyncio.ensure_future(sender(ws)),\n            asyncio.ensure_future(receiver(ws))\n        ])\n\ndef parse_args():\n    \"\"\" Parses the command-line arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Submits data to the real-time streaming endpoint.')\n    parser.add_argument('-k', '--key', required=True, help='YOUR_DEEPGRAM_API_KEY (authorization)')\n    parser.add_argument('-s', '--silence', required=False, help='A float representing the number of seconds of silence to wait before playing a beep. Defaults to 2.0.', default=2.0)\n    return parser.parse_args()\n\ndef main():\n    args = parse_args()\n\n    loop = asyncio.get_event_loop()\n    asyncio.get_event_loop().run_until_complete(run(args.key, float(args.silence)))\n\nif __name__ == '__main__':\n    sys.exit(main() or 0)\n```\n\nThese two examples should give you an idea of how different conversational flow mechanisms feel, and how they can be incorporated into different types of real-time speech-to-text applications. Both can be found in this [GitHub repo](https://github.com/deepgram/conversational-ai-flow).\n\nWe hope these examples help as you decide how to best utilize Deepgram's functionality. Happy building!\n\n", "html": `<p>How do you know when someone is finished talking? Before I started working at Deepgram, I hadn\u2019t thought about this question much. When having conversations in person, us humans can use all sorts of contextual cues, body language, and societal norms to figure out when someone has finished their thought and we can jump in with our own opinion. But as we\u2019ve all seen over Zoom during the last few years, figuring out when someone is done talking is a lot harder to do virtually. It\u2019s even harder when the listener isn\u2019t human at all\u2014and is a machine learning model transcribing speech!</p>
<p>Business problems that need speech-to-text often also need an understanding of when a speaker has completed their thought. One common use case for this is building conversational AI bots that need to respond to a user\u2019s queries. The bot needs to be careful both to not to cut the user off, and to respond in a timely enough manner that the conversation feels \u201Creal-time\u201D.</p>
<p>Deepgram\u2019s real-time speech-to-text service provides two main mechanisms that can help build a conversational flow. One is interim results, and the other is endpointing. Together, the two can give you information about when a speaker has finished talking, and when your system should respond.</p>
<p><a href="https://developers.deepgram.com/documentation/features/interim-results/">Interim results</a>, which are disabled by default, are sent back every few seconds. These messages, marked with <code is:raw>is_final=false</code>,  indicate that Deepgram is still gathering more audio and the transcription results may change as additional context is given. Once Deepgram has collected enough audio to make the best possible prediction, it will finalize the prediction and send back a transcript marked with <code is:raw>is_final=true</code>.</p>
<p><a href="https://developers.deepgram.com/documentation/features/endpointing/">Endpointing</a>, which is enabled by default, is an algorithm that detects the end of speech. When endpointing triggers, Deepgram immediately sends back a message. These messages will be marked with <code is:raw>speech_final=true</code> to indicate an endpoint was detected and <code is:raw>is_final=true </code>to indicate the transcription is finalized.</p>
<p>The simplest way to determine when someone is done talking is based on silence. Endpointing can give you almost immediate feedback when silence is detected, which may be useful for applications that prioritize quick processing of results. Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound when Deepgram detects an endpoint.</p>
<p>To run the code, install beepy using <code is:raw>pip install beepy</code>. Then save the following code as <code is:raw>endpointing.py</code>. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:</p>
<p><code is:raw>python endpointing.py  -k 'YOUR_DG_API_KEY'</code></p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> pyaudio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> time</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> argparse</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> beepy</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.paInt16</span></span>
<span class="line"><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">16000</span></span>
<span class="line"><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">callback</span><span style="color: #C9D1D9">(input_data, frame_count, time_info, status_flag):</span></span>
<span class="line"><span style="color: #C9D1D9">    audio_queue.put_nowait(input_data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> (input_data, pyaudio.paContinue)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">run</span><span style="color: #C9D1D9">(key):</span></span>
<span class="line"><span style="color: #C9D1D9">    extra_headers</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token </span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">.format(key)</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> websockets.connect(</span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?endpointing=true&amp;encoding=linear16&amp;sample_rate=16000&amp;channels=1&amp;interim_results=false&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">extra_headers</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> extra_headers) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">microphone</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">            audio </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.PyAudio()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> audio.open(</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">format</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">channels</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">rate</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">input</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">frames_per_buffer</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">stream_callback</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callback</span></span>
<span class="line"><span style="color: #C9D1D9">            )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.start_stream()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> stream.is_active():</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.sleep(</span><span style="color: #79C0FF">0.1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.stop_stream()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sender</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> ws.send(data)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">Exception</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> e:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Error while sending: &#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">str</span><span style="color: #C9D1D9">(e)))</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">raise</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">receiver</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> msg </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">                msg </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(msg)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(msg[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript):</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39; &#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                    transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> msg[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript, </span><span style="color: #FFA657">end</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\r</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> msg[</span><span style="color: #A5D6FF">&#39;speech_final&#39;</span><span style="color: #C9D1D9">]:</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript)</span></span>
<span class="line"><span style="color: #C9D1D9">                        beepy.beep(</span><span style="color: #FFA657">sound</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(microphone()),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(sender(ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(receiver(ws))</span></span>
<span class="line"><span style="color: #C9D1D9">        ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_args</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&quot;&quot;&quot; Parses the command-line arguments.</span></span>
<span class="line"><span style="color: #A5D6FF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    parser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> argparse.ArgumentParser(</span><span style="color: #FFA657">description</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;Submits data to the real-time streaming endpoint.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-k&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--key&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;YOUR_DEEPGRAM_API_KEY (authorization)&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> parser.parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    args </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.get_event_loop().run_until_complete(run(args.key))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>As you may notice when using <code is:raw>endpointing.py</code>, Deepgram will detect that you have finished speaking as soon as possible, meaning that in a conversational flow, this logic can easily cut you off mid-sentence every time you make even a minor pause. Rather than responding immediately, many applications will want to wait for a few seconds after a speaker finishes talking. This can be especially effective in conversational AI, where users may be speaking for long durations and occasionally pause mid-thought\u2014waiting a few seconds to respond may result in a more natural conversational flow. A combination of endpointing and interim results can be used to determine when a desired duration of silence has passed.</p>
<p>Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound after the number of seconds defined in a configurable <code is:raw>SILENCE_INTERVAL</code> has passed. (The default is 2.0, but this can be specified when running the script.)</p>
<p>To run the code, install beepy using <code is:raw>pip install beepy</code>. Then save the following code as <code is:raw>silence_interval.py</code>. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:</p>
<p><code is:raw>python silence_interval.py  -k 'YOUR_DG_API_KEY' [-s SILENCE_INTERVAL_SECONDS_FLOAT]</code></p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> pyaudio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> beepy</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> shutil</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> argparse</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.paInt16</span></span>
<span class="line"><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">16000</span></span>
<span class="line"><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">terminal_size </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> shutil.get_terminal_size()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">callback</span><span style="color: #C9D1D9">(input_data, frame_count, time_info, status_flag):</span></span>
<span class="line"><span style="color: #C9D1D9">    audio_queue.put_nowait(input_data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> (input_data, pyaudio.paContinue)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">run</span><span style="color: #C9D1D9">(key, silence_interval):</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> websockets.connect(</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?endpointing=true&amp;interim_results=true&amp;encoding=linear16&amp;sample_rate=16000&amp;channels=1&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">extra_headers</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token </span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">.format(key)</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    ) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">microphone</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">            audio </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.PyAudio()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> audio.open(</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">format</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">channels</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">rate</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">input</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">frames_per_buffer</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">stream_callback</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callback</span></span>
<span class="line"><span style="color: #C9D1D9">            )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.start_stream()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> stream.is_active():</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.sleep(</span><span style="color: #79C0FF">0.1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.stop_stream()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sender</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> ws.send(data)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">Exception</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> e:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Error while sending: &#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">str</span><span style="color: #C9D1D9">(e)))</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">raise</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">receiver</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">            last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">            should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">                message </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(message)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                transcript_cursor </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;duration&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #8B949E"># if there are any words in the message</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># handle transcript printing for final messages</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;is_final&#39;</span><span style="color: #C9D1D9">]:</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript):</span></span>
<span class="line"><span style="color: #C9D1D9">                            transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39; &#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript)</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #8B949E"># overwrite the line regardless of length</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #8B949E"># https://stackoverflow.com/a/47170056</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\033</span><span style="color: #A5D6FF">[</span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">A&#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript) </span><span style="color: #FF7B72">//</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(terminal_size.columns) </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">), </span><span style="color: #FFA657">end</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># if the last word in a previous message is silence_interval seconds</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># older than the first word in this message (and if that last word hasn&#39;t already triggered a beep)</span></span>
<span class="line"><span style="color: #C9D1D9">                    current_word_begin </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> current_word_begin </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> silence_interval </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                        should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;end&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># if there were no words in this message, check if the the last word</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># in a previous message is silence_interval or more seconds older</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># than the timestamp at the end of this message (if that last word hasn&#39;t already triggered a beep)</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript_cursor </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> silence_interval </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                        last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">                        should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> should_beep:</span></span>
<span class="line"><span style="color: #C9D1D9">                    beepy.beep(</span><span style="color: #FFA657">sound</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">                    should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># we set/mark last_word_end to 0.0 to indicate that this last word has already triggered a beep</span></span>
<span class="line"><span style="color: #C9D1D9">                    last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">                    transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(microphone()),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(sender(ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(receiver(ws))</span></span>
<span class="line"><span style="color: #C9D1D9">        ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_args</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&quot;&quot;&quot; Parses the command-line arguments.</span></span>
<span class="line"><span style="color: #A5D6FF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    parser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> argparse.ArgumentParser(</span><span style="color: #FFA657">description</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;Submits data to the real-time streaming endpoint.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-k&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--key&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;YOUR_DEEPGRAM_API_KEY (authorization)&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-s&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--silence&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">False</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;A float representing the number of seconds of silence to wait before playing a beep. Defaults to 2.0.&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">default</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">2.0</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> parser.parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    args </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    loop </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.get_event_loop()</span></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.get_event_loop().run_until_complete(run(args.key, </span><span style="color: #79C0FF">float</span><span style="color: #C9D1D9">(args.silence)))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>These two examples should give you an idea of how different conversational flow mechanisms feel, and how they can be incorporated into different types of real-time speech-to-text applications. Both can be found in this <a href="https://github.com/deepgram/conversational-ai-flow">GitHub repo</a>.</p>
<p>We hope these examples help as you decide how to best utilize Deepgram\u2019s functionality. Happy building!</p>` };
const frontmatter = { "title": "Building a Conversational AI Flow with Deepgram", "description": "Learn how to use endpointing and interim results to build a conversational AI flow.", "date": "2022-09-23T17:38:18.493Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1664336619/blog/Building-Conversational-AI-Flow-with-Deepgram/2209-Building-Conversational-AI-Flow-with-Deepgram-thumb-554x220_vkzldi.png", "authors": ["shir-goldberg"], "category": "tutorial", "tags": ["conversational-ai", "endpointing", "interim-results"], "seo": { "title": "Building a Conversational AI Flow with Deepgram", "description": "Learn how to use endpointing and interim results to build a conversational AI flow." }, "shorturls": { "share": "https://dpgr.am/daf3c23", "twitter": "https://dpgr.am/b6afcdf", "linkedin": "https://dpgr.am/3be026a", "reddit": "https://dpgr.am/96c7583", "facebook": "https://dpgr.am/a099e21" }, "astro": { "headings": [], "source": "\nHow do you know when someone is finished talking? Before I started working at Deepgram, I hadn\u2019t thought about this question much. When having conversations in person, us humans can use all sorts of contextual cues, body language, and societal norms to figure out when someone has finished their thought and we can jump in with our own opinion. But as we\u2019ve all seen over Zoom during the last few years, figuring out when someone is done talking is a lot harder to do virtually. It\u2019s even harder when the listener isn\u2019t human at all\u2014and is a machine learning model transcribing speech!\n\nBusiness problems that need speech-to-text often also need an understanding of when a speaker has completed their thought. One common use case for this is building conversational AI bots that need to respond to a user\u2019s queries. The bot needs to be careful both to not to cut the user off, and to respond in a timely enough manner that the conversation feels \u201Creal-time\u201D.\n\nDeepgram\u2019s real-time speech-to-text service provides two main mechanisms that can help build a conversational flow. One is interim results, and the other is endpointing. Together, the two can give you information about when a speaker has finished talking, and when your system should respond.\n\n[Interim results](https://developers.deepgram.com/documentation/features/interim-results/), which are disabled by default, are sent back every few seconds. These messages, marked with `is_final=false`,  indicate that Deepgram is still gathering more audio and the transcription results may change as additional context is given. Once Deepgram has collected enough audio to make the best possible prediction, it will finalize the prediction and send back a transcript marked with `is_final=true`.\n\n[Endpointing](https://developers.deepgram.com/documentation/features/endpointing/), which is enabled by default, is an algorithm that detects the end of speech. When endpointing triggers, Deepgram immediately sends back a message. These messages will be marked with `speech_final=true` to indicate an endpoint was detected and `is_final=true `to indicate the transcription is finalized.\n\nThe simplest way to determine when someone is done talking is based on silence. Endpointing can give you almost immediate feedback when silence is detected, which may be useful for applications that prioritize quick processing of results. Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound when Deepgram detects an endpoint.\n\nTo run the code, install beepy using `pip install beepy`. Then save the following code as `endpointing.py`. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:\n\n`python endpointing.py  -k 'YOUR_DG_API_KEY'`\n\n```python\nimport pyaudio\nimport asyncio\nimport sys\nimport websockets\nimport time\nimport json\nimport argparse\nimport beepy\n\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 8000\n\naudio_queue = asyncio.Queue()\n\ndef callback(input_data, frame_count, time_info, status_flag):\n    audio_queue.put_nowait(input_data)\n    return (input_data, pyaudio.paContinue)\n\nasync def run(key):\n    extra_headers={\n        'Authorization': 'Token {}'.format(key)\n    }\n    async with websockets.connect('wss://api.deepgram.com/v1/listen?endpointing=true&encoding=linear16&sample_rate=16000&channels=1&interim_results=false', extra_headers = extra_headers) as ws:\n        async def microphone():\n            audio = pyaudio.PyAudio()\n            stream = audio.open(\n                format = FORMAT,\n                channels = CHANNELS,\n                rate = RATE,\n                input = True,\n                frames_per_buffer = CHUNK,\n                stream_callback = callback\n            )\n\n            stream.start_stream()\n\n            while stream.is_active():\n                await asyncio.sleep(0.1)\n\n            stream.stop_stream()\n            stream.close()\n\n        async def sender(ws):\n            try:\n                while True:\n                    data = await audio_queue.get()\n                    await ws.send(data)\n            except Exception as e:\n                print('Error while sending: '.format(str(e)))\n                raise\n\n        async def receiver(ws):\n            transcript = ''\n            async for msg in ws:\n                msg = json.loads(msg)\n\n                if len(msg['channel']['alternatives'][0]['transcript']) > 0:\n                    if len(transcript):\n                        transcript += ' '\n                    transcript += msg['channel']['alternatives'][0]['transcript']\n                    print(transcript, end = '\\r')\n\n                    if msg['speech_final']:\n                        print(transcript)\n                        beepy.beep(sound=1)\n                        transcript = ''\n\n        await asyncio.wait([\n            asyncio.ensure_future(microphone()),\n            asyncio.ensure_future(sender(ws)),\n            asyncio.ensure_future(receiver(ws))\n        ])\n\ndef parse_args():\n    \"\"\" Parses the command-line arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Submits data to the real-time streaming endpoint.')\n    parser.add_argument('-k', '--key', required=True, help='YOUR_DEEPGRAM_API_KEY (authorization)')\n    return parser.parse_args()\n\ndef main():\n    args = parse_args()\n\n    asyncio.get_event_loop().run_until_complete(run(args.key))\n\nif __name__ == '__main__':\n    sys.exit(main() or 0)\n```\n\nAs you may notice when using `endpointing.py`, Deepgram will detect that you have finished speaking as soon as possible, meaning that in a conversational flow, this logic can easily cut you off mid-sentence every time you make even a minor pause. Rather than responding immediately, many applications will want to wait for a few seconds after a speaker finishes talking. This can be especially effective in conversational AI, where users may be speaking for long durations and occasionally pause mid-thought\u2014waiting a few seconds to respond may result in a more natural conversational flow. A combination of endpointing and interim results can be used to determine when a desired duration of silence has passed.\n\nHere\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound after the number of seconds defined in a configurable `SILENCE_INTERVAL` has passed. (The default is 2.0, but this can be specified when running the script.)\n\nTo run the code, install beepy using `pip install beepy`. Then save the following code as `silence_interval.py`. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:\n\n`python silence_interval.py  -k 'YOUR_DG_API_KEY' [-s SILENCE_INTERVAL_SECONDS_FLOAT]`\n\n```python\nimport pyaudio\nimport asyncio\nimport sys\nimport websockets\nimport json\nimport beepy\nimport shutil\nimport argparse\n\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 8000\n\nterminal_size = shutil.get_terminal_size()\n\naudio_queue = asyncio.Queue()\n\ndef callback(input_data, frame_count, time_info, status_flag):\n    audio_queue.put_nowait(input_data)\n    return (input_data, pyaudio.paContinue)\n\nasync def run(key, silence_interval):\n    async with websockets.connect(\n        'wss://api.deepgram.com/v1/listen?endpointing=true&interim_results=true&encoding=linear16&sample_rate=16000&channels=1',\n        extra_headers={\n            'Authorization': 'Token {}'.format(key)\n        }\n    ) as ws:\n        async def microphone():\n            audio = pyaudio.PyAudio()\n            stream = audio.open(\n                format = FORMAT,\n                channels = CHANNELS,\n                rate = RATE,\n                input = True,\n                frames_per_buffer = CHUNK,\n                stream_callback = callback\n            )\n\n            stream.start_stream()\n\n            while stream.is_active():\n                await asyncio.sleep(0.1)\n\n            stream.stop_stream()\n            stream.close()\n\n        async def sender(ws):\n            try:\n                while True:\n                    data = await audio_queue.get()\n                    await ws.send(data)\n            except Exception as e:\n                print('Error while sending: '.format(str(e)))\n                raise\n\n        async def receiver(ws):\n            transcript = ''\n            last_word_end = 0.0\n            should_beep = False\n\n            async for message in ws:\n                message = json.loads(message)\n\n                transcript_cursor = message['start'] + message['duration']\n\n                # if there are any words in the message\n                if len(message['channel']['alternatives'][0]['words']) > 0:\n                    # handle transcript printing for final messages\n                    if message['is_final']:\n                        if len(transcript):\n                            transcript += ' '\n                        transcript += message['channel']['alternatives'][0]['transcript']\n                        print(transcript)\n                        # overwrite the line regardless of length\n                        # https://stackoverflow.com/a/47170056\n                        print('\\033[{}A'.format(len(transcript) // int(terminal_size.columns) + 1), end='')\n\n                    # if the last word in a previous message is silence_interval seconds\n                    # older than the first word in this message (and if that last word hasn't already triggered a beep)\n                    current_word_begin = message['channel']['alternatives'][0]['words'][0]['start']\n                    if current_word_begin - last_word_end >= silence_interval and last_word_end != 0.0:\n                        should_beep = True\n\n                    last_word_end = message['channel']['alternatives'][0]['words'][-1]['end']\n                else:\n                    # if there were no words in this message, check if the the last word\n                    # in a previous message is silence_interval or more seconds older\n                    # than the timestamp at the end of this message (if that last word hasn't already triggered a beep)\n                    if transcript_cursor - last_word_end >= silence_interval and last_word_end != 0.0:\n                        last_word_end = 0.0\n                        should_beep = True\n\n                if should_beep:\n                    beepy.beep(sound=1)\n                    should_beep = False\n                    # we set/mark last_word_end to 0.0 to indicate that this last word has already triggered a beep\n                    last_word_end = 0.0\n                    transcript = ''\n                    print('')\n\n        await asyncio.wait([\n            asyncio.ensure_future(microphone()),\n            asyncio.ensure_future(sender(ws)),\n            asyncio.ensure_future(receiver(ws))\n        ])\n\ndef parse_args():\n    \"\"\" Parses the command-line arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Submits data to the real-time streaming endpoint.')\n    parser.add_argument('-k', '--key', required=True, help='YOUR_DEEPGRAM_API_KEY (authorization)')\n    parser.add_argument('-s', '--silence', required=False, help='A float representing the number of seconds of silence to wait before playing a beep. Defaults to 2.0.', default=2.0)\n    return parser.parse_args()\n\ndef main():\n    args = parse_args()\n\n    loop = asyncio.get_event_loop()\n    asyncio.get_event_loop().run_until_complete(run(args.key, float(args.silence)))\n\nif __name__ == '__main__':\n    sys.exit(main() or 0)\n```\n\nThese two examples should give you an idea of how different conversational flow mechanisms feel, and how they can be incorporated into different types of real-time speech-to-text applications. Both can be found in this [GitHub repo](https://github.com/deepgram/conversational-ai-flow).\n\nWe hope these examples help as you decide how to best utilize Deepgram's functionality. Happy building!\n\n", "html": `<p>How do you know when someone is finished talking? Before I started working at Deepgram, I hadn\u2019t thought about this question much. When having conversations in person, us humans can use all sorts of contextual cues, body language, and societal norms to figure out when someone has finished their thought and we can jump in with our own opinion. But as we\u2019ve all seen over Zoom during the last few years, figuring out when someone is done talking is a lot harder to do virtually. It\u2019s even harder when the listener isn\u2019t human at all\u2014and is a machine learning model transcribing speech!</p>
<p>Business problems that need speech-to-text often also need an understanding of when a speaker has completed their thought. One common use case for this is building conversational AI bots that need to respond to a user\u2019s queries. The bot needs to be careful both to not to cut the user off, and to respond in a timely enough manner that the conversation feels \u201Creal-time\u201D.</p>
<p>Deepgram\u2019s real-time speech-to-text service provides two main mechanisms that can help build a conversational flow. One is interim results, and the other is endpointing. Together, the two can give you information about when a speaker has finished talking, and when your system should respond.</p>
<p><a href="https://developers.deepgram.com/documentation/features/interim-results/">Interim results</a>, which are disabled by default, are sent back every few seconds. These messages, marked with <code is:raw>is_final=false</code>,  indicate that Deepgram is still gathering more audio and the transcription results may change as additional context is given. Once Deepgram has collected enough audio to make the best possible prediction, it will finalize the prediction and send back a transcript marked with <code is:raw>is_final=true</code>.</p>
<p><a href="https://developers.deepgram.com/documentation/features/endpointing/">Endpointing</a>, which is enabled by default, is an algorithm that detects the end of speech. When endpointing triggers, Deepgram immediately sends back a message. These messages will be marked with <code is:raw>speech_final=true</code> to indicate an endpoint was detected and <code is:raw>is_final=true </code>to indicate the transcription is finalized.</p>
<p>The simplest way to determine when someone is done talking is based on silence. Endpointing can give you almost immediate feedback when silence is detected, which may be useful for applications that prioritize quick processing of results. Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound when Deepgram detects an endpoint.</p>
<p>To run the code, install beepy using <code is:raw>pip install beepy</code>. Then save the following code as <code is:raw>endpointing.py</code>. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:</p>
<p><code is:raw>python endpointing.py  -k 'YOUR_DG_API_KEY'</code></p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> pyaudio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> time</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> argparse</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> beepy</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.paInt16</span></span>
<span class="line"><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">16000</span></span>
<span class="line"><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">callback</span><span style="color: #C9D1D9">(input_data, frame_count, time_info, status_flag):</span></span>
<span class="line"><span style="color: #C9D1D9">    audio_queue.put_nowait(input_data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> (input_data, pyaudio.paContinue)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">run</span><span style="color: #C9D1D9">(key):</span></span>
<span class="line"><span style="color: #C9D1D9">    extra_headers</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token </span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">.format(key)</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> websockets.connect(</span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?endpointing=true&amp;encoding=linear16&amp;sample_rate=16000&amp;channels=1&amp;interim_results=false&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">extra_headers</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> extra_headers) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">microphone</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">            audio </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.PyAudio()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> audio.open(</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">format</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">channels</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">rate</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">input</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">frames_per_buffer</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">stream_callback</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callback</span></span>
<span class="line"><span style="color: #C9D1D9">            )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.start_stream()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> stream.is_active():</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.sleep(</span><span style="color: #79C0FF">0.1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.stop_stream()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sender</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> ws.send(data)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">Exception</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> e:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Error while sending: &#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">str</span><span style="color: #C9D1D9">(e)))</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">raise</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">receiver</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> msg </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">                msg </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(msg)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(msg[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript):</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39; &#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                    transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> msg[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript, </span><span style="color: #FFA657">end</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\r</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> msg[</span><span style="color: #A5D6FF">&#39;speech_final&#39;</span><span style="color: #C9D1D9">]:</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript)</span></span>
<span class="line"><span style="color: #C9D1D9">                        beepy.beep(</span><span style="color: #FFA657">sound</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(microphone()),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(sender(ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(receiver(ws))</span></span>
<span class="line"><span style="color: #C9D1D9">        ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_args</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&quot;&quot;&quot; Parses the command-line arguments.</span></span>
<span class="line"><span style="color: #A5D6FF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    parser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> argparse.ArgumentParser(</span><span style="color: #FFA657">description</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;Submits data to the real-time streaming endpoint.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-k&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--key&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;YOUR_DEEPGRAM_API_KEY (authorization)&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> parser.parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    args </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.get_event_loop().run_until_complete(run(args.key))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>As you may notice when using <code is:raw>endpointing.py</code>, Deepgram will detect that you have finished speaking as soon as possible, meaning that in a conversational flow, this logic can easily cut you off mid-sentence every time you make even a minor pause. Rather than responding immediately, many applications will want to wait for a few seconds after a speaker finishes talking. This can be especially effective in conversational AI, where users may be speaking for long durations and occasionally pause mid-thought\u2014waiting a few seconds to respond may result in a more natural conversational flow. A combination of endpointing and interim results can be used to determine when a desired duration of silence has passed.</p>
<p>Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound after the number of seconds defined in a configurable <code is:raw>SILENCE_INTERVAL</code> has passed. (The default is 2.0, but this can be specified when running the script.)</p>
<p>To run the code, install beepy using <code is:raw>pip install beepy</code>. Then save the following code as <code is:raw>silence_interval.py</code>. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:</p>
<p><code is:raw>python silence_interval.py  -k 'YOUR_DG_API_KEY' [-s SILENCE_INTERVAL_SECONDS_FLOAT]</code></p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> pyaudio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> beepy</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> shutil</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> argparse</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.paInt16</span></span>
<span class="line"><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">16000</span></span>
<span class="line"><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">terminal_size </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> shutil.get_terminal_size()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">callback</span><span style="color: #C9D1D9">(input_data, frame_count, time_info, status_flag):</span></span>
<span class="line"><span style="color: #C9D1D9">    audio_queue.put_nowait(input_data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> (input_data, pyaudio.paContinue)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">run</span><span style="color: #C9D1D9">(key, silence_interval):</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> websockets.connect(</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?endpointing=true&amp;interim_results=true&amp;encoding=linear16&amp;sample_rate=16000&amp;channels=1&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">extra_headers</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token </span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">.format(key)</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    ) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">microphone</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">            audio </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.PyAudio()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> audio.open(</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">format</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">channels</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">rate</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">input</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">frames_per_buffer</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">stream_callback</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callback</span></span>
<span class="line"><span style="color: #C9D1D9">            )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.start_stream()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> stream.is_active():</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.sleep(</span><span style="color: #79C0FF">0.1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.stop_stream()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sender</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> ws.send(data)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">Exception</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> e:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Error while sending: &#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">str</span><span style="color: #C9D1D9">(e)))</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">raise</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">receiver</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">            last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">            should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">                message </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(message)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                transcript_cursor </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;duration&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #8B949E"># if there are any words in the message</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># handle transcript printing for final messages</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;is_final&#39;</span><span style="color: #C9D1D9">]:</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript):</span></span>
<span class="line"><span style="color: #C9D1D9">                            transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39; &#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript)</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #8B949E"># overwrite the line regardless of length</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #8B949E"># https://stackoverflow.com/a/47170056</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\033</span><span style="color: #A5D6FF">[</span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">A&#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript) </span><span style="color: #FF7B72">//</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(terminal_size.columns) </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">), </span><span style="color: #FFA657">end</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># if the last word in a previous message is silence_interval seconds</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># older than the first word in this message (and if that last word hasn&#39;t already triggered a beep)</span></span>
<span class="line"><span style="color: #C9D1D9">                    current_word_begin </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> current_word_begin </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> silence_interval </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                        should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;end&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># if there were no words in this message, check if the the last word</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># in a previous message is silence_interval or more seconds older</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># than the timestamp at the end of this message (if that last word hasn&#39;t already triggered a beep)</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript_cursor </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> silence_interval </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                        last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">                        should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> should_beep:</span></span>
<span class="line"><span style="color: #C9D1D9">                    beepy.beep(</span><span style="color: #FFA657">sound</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">                    should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># we set/mark last_word_end to 0.0 to indicate that this last word has already triggered a beep</span></span>
<span class="line"><span style="color: #C9D1D9">                    last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">                    transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(microphone()),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(sender(ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(receiver(ws))</span></span>
<span class="line"><span style="color: #C9D1D9">        ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_args</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&quot;&quot;&quot; Parses the command-line arguments.</span></span>
<span class="line"><span style="color: #A5D6FF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    parser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> argparse.ArgumentParser(</span><span style="color: #FFA657">description</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;Submits data to the real-time streaming endpoint.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-k&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--key&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;YOUR_DEEPGRAM_API_KEY (authorization)&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-s&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--silence&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">False</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;A float representing the number of seconds of silence to wait before playing a beep. Defaults to 2.0.&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">default</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">2.0</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> parser.parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    args </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    loop </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.get_event_loop()</span></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.get_event_loop().run_until_complete(run(args.key, </span><span style="color: #79C0FF">float</span><span style="color: #C9D1D9">(args.silence)))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>These two examples should give you an idea of how different conversational flow mechanisms feel, and how they can be incorporated into different types of real-time speech-to-text applications. Both can be found in this <a href="https://github.com/deepgram/conversational-ai-flow">GitHub repo</a>.</p>
<p>We hope these examples help as you decide how to best utilize Deepgram\u2019s functionality. Happy building!</p>` }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/building-a-conversational-ai-flow-with-deepgram/index.md" };
function rawContent() {
  return "\nHow do you know when someone is finished talking? Before I started working at Deepgram, I hadn\u2019t thought about this question much. When having conversations in person, us humans can use all sorts of contextual cues, body language, and societal norms to figure out when someone has finished their thought and we can jump in with our own opinion. But as we\u2019ve all seen over Zoom during the last few years, figuring out when someone is done talking is a lot harder to do virtually. It\u2019s even harder when the listener isn\u2019t human at all\u2014and is a machine learning model transcribing speech!\n\nBusiness problems that need speech-to-text often also need an understanding of when a speaker has completed their thought. One common use case for this is building conversational AI bots that need to respond to a user\u2019s queries. The bot needs to be careful both to not to cut the user off, and to respond in a timely enough manner that the conversation feels \u201Creal-time\u201D.\n\nDeepgram\u2019s real-time speech-to-text service provides two main mechanisms that can help build a conversational flow. One is interim results, and the other is endpointing. Together, the two can give you information about when a speaker has finished talking, and when your system should respond.\n\n[Interim results](https://developers.deepgram.com/documentation/features/interim-results/), which are disabled by default, are sent back every few seconds. These messages, marked with `is_final=false`,  indicate that Deepgram is still gathering more audio and the transcription results may change as additional context is given. Once Deepgram has collected enough audio to make the best possible prediction, it will finalize the prediction and send back a transcript marked with `is_final=true`.\n\n[Endpointing](https://developers.deepgram.com/documentation/features/endpointing/), which is enabled by default, is an algorithm that detects the end of speech. When endpointing triggers, Deepgram immediately sends back a message. These messages will be marked with `speech_final=true` to indicate an endpoint was detected and `is_final=true `to indicate the transcription is finalized.\n\nThe simplest way to determine when someone is done talking is based on silence. Endpointing can give you almost immediate feedback when silence is detected, which may be useful for applications that prioritize quick processing of results. Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound when Deepgram detects an endpoint.\n\nTo run the code, install beepy using `pip install beepy`. Then save the following code as `endpointing.py`. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:\n\n`python endpointing.py  -k 'YOUR_DG_API_KEY'`\n\n```python\nimport pyaudio\nimport asyncio\nimport sys\nimport websockets\nimport time\nimport json\nimport argparse\nimport beepy\n\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 8000\n\naudio_queue = asyncio.Queue()\n\ndef callback(input_data, frame_count, time_info, status_flag):\n    audio_queue.put_nowait(input_data)\n    return (input_data, pyaudio.paContinue)\n\nasync def run(key):\n    extra_headers={\n        'Authorization': 'Token {}'.format(key)\n    }\n    async with websockets.connect('wss://api.deepgram.com/v1/listen?endpointing=true&encoding=linear16&sample_rate=16000&channels=1&interim_results=false', extra_headers = extra_headers) as ws:\n        async def microphone():\n            audio = pyaudio.PyAudio()\n            stream = audio.open(\n                format = FORMAT,\n                channels = CHANNELS,\n                rate = RATE,\n                input = True,\n                frames_per_buffer = CHUNK,\n                stream_callback = callback\n            )\n\n            stream.start_stream()\n\n            while stream.is_active():\n                await asyncio.sleep(0.1)\n\n            stream.stop_stream()\n            stream.close()\n\n        async def sender(ws):\n            try:\n                while True:\n                    data = await audio_queue.get()\n                    await ws.send(data)\n            except Exception as e:\n                print('Error while sending: '.format(str(e)))\n                raise\n\n        async def receiver(ws):\n            transcript = ''\n            async for msg in ws:\n                msg = json.loads(msg)\n\n                if len(msg['channel']['alternatives'][0]['transcript']) > 0:\n                    if len(transcript):\n                        transcript += ' '\n                    transcript += msg['channel']['alternatives'][0]['transcript']\n                    print(transcript, end = '\\r')\n\n                    if msg['speech_final']:\n                        print(transcript)\n                        beepy.beep(sound=1)\n                        transcript = ''\n\n        await asyncio.wait([\n            asyncio.ensure_future(microphone()),\n            asyncio.ensure_future(sender(ws)),\n            asyncio.ensure_future(receiver(ws))\n        ])\n\ndef parse_args():\n    \"\"\" Parses the command-line arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Submits data to the real-time streaming endpoint.')\n    parser.add_argument('-k', '--key', required=True, help='YOUR_DEEPGRAM_API_KEY (authorization)')\n    return parser.parse_args()\n\ndef main():\n    args = parse_args()\n\n    asyncio.get_event_loop().run_until_complete(run(args.key))\n\nif __name__ == '__main__':\n    sys.exit(main() or 0)\n```\n\nAs you may notice when using `endpointing.py`, Deepgram will detect that you have finished speaking as soon as possible, meaning that in a conversational flow, this logic can easily cut you off mid-sentence every time you make even a minor pause. Rather than responding immediately, many applications will want to wait for a few seconds after a speaker finishes talking. This can be especially effective in conversational AI, where users may be speaking for long durations and occasionally pause mid-thought\u2014waiting a few seconds to respond may result in a more natural conversational flow. A combination of endpointing and interim results can be used to determine when a desired duration of silence has passed.\n\nHere\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound after the number of seconds defined in a configurable `SILENCE_INTERVAL` has passed. (The default is 2.0, but this can be specified when running the script.)\n\nTo run the code, install beepy using `pip install beepy`. Then save the following code as `silence_interval.py`. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:\n\n`python silence_interval.py  -k 'YOUR_DG_API_KEY' [-s SILENCE_INTERVAL_SECONDS_FLOAT]`\n\n```python\nimport pyaudio\nimport asyncio\nimport sys\nimport websockets\nimport json\nimport beepy\nimport shutil\nimport argparse\n\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 8000\n\nterminal_size = shutil.get_terminal_size()\n\naudio_queue = asyncio.Queue()\n\ndef callback(input_data, frame_count, time_info, status_flag):\n    audio_queue.put_nowait(input_data)\n    return (input_data, pyaudio.paContinue)\n\nasync def run(key, silence_interval):\n    async with websockets.connect(\n        'wss://api.deepgram.com/v1/listen?endpointing=true&interim_results=true&encoding=linear16&sample_rate=16000&channels=1',\n        extra_headers={\n            'Authorization': 'Token {}'.format(key)\n        }\n    ) as ws:\n        async def microphone():\n            audio = pyaudio.PyAudio()\n            stream = audio.open(\n                format = FORMAT,\n                channels = CHANNELS,\n                rate = RATE,\n                input = True,\n                frames_per_buffer = CHUNK,\n                stream_callback = callback\n            )\n\n            stream.start_stream()\n\n            while stream.is_active():\n                await asyncio.sleep(0.1)\n\n            stream.stop_stream()\n            stream.close()\n\n        async def sender(ws):\n            try:\n                while True:\n                    data = await audio_queue.get()\n                    await ws.send(data)\n            except Exception as e:\n                print('Error while sending: '.format(str(e)))\n                raise\n\n        async def receiver(ws):\n            transcript = ''\n            last_word_end = 0.0\n            should_beep = False\n\n            async for message in ws:\n                message = json.loads(message)\n\n                transcript_cursor = message['start'] + message['duration']\n\n                # if there are any words in the message\n                if len(message['channel']['alternatives'][0]['words']) > 0:\n                    # handle transcript printing for final messages\n                    if message['is_final']:\n                        if len(transcript):\n                            transcript += ' '\n                        transcript += message['channel']['alternatives'][0]['transcript']\n                        print(transcript)\n                        # overwrite the line regardless of length\n                        # https://stackoverflow.com/a/47170056\n                        print('\\033[{}A'.format(len(transcript) // int(terminal_size.columns) + 1), end='')\n\n                    # if the last word in a previous message is silence_interval seconds\n                    # older than the first word in this message (and if that last word hasn't already triggered a beep)\n                    current_word_begin = message['channel']['alternatives'][0]['words'][0]['start']\n                    if current_word_begin - last_word_end >= silence_interval and last_word_end != 0.0:\n                        should_beep = True\n\n                    last_word_end = message['channel']['alternatives'][0]['words'][-1]['end']\n                else:\n                    # if there were no words in this message, check if the the last word\n                    # in a previous message is silence_interval or more seconds older\n                    # than the timestamp at the end of this message (if that last word hasn't already triggered a beep)\n                    if transcript_cursor - last_word_end >= silence_interval and last_word_end != 0.0:\n                        last_word_end = 0.0\n                        should_beep = True\n\n                if should_beep:\n                    beepy.beep(sound=1)\n                    should_beep = False\n                    # we set/mark last_word_end to 0.0 to indicate that this last word has already triggered a beep\n                    last_word_end = 0.0\n                    transcript = ''\n                    print('')\n\n        await asyncio.wait([\n            asyncio.ensure_future(microphone()),\n            asyncio.ensure_future(sender(ws)),\n            asyncio.ensure_future(receiver(ws))\n        ])\n\ndef parse_args():\n    \"\"\" Parses the command-line arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Submits data to the real-time streaming endpoint.')\n    parser.add_argument('-k', '--key', required=True, help='YOUR_DEEPGRAM_API_KEY (authorization)')\n    parser.add_argument('-s', '--silence', required=False, help='A float representing the number of seconds of silence to wait before playing a beep. Defaults to 2.0.', default=2.0)\n    return parser.parse_args()\n\ndef main():\n    args = parse_args()\n\n    loop = asyncio.get_event_loop()\n    asyncio.get_event_loop().run_until_complete(run(args.key, float(args.silence)))\n\nif __name__ == '__main__':\n    sys.exit(main() or 0)\n```\n\nThese two examples should give you an idea of how different conversational flow mechanisms feel, and how they can be incorporated into different types of real-time speech-to-text applications. Both can be found in this [GitHub repo](https://github.com/deepgram/conversational-ai-flow).\n\nWe hope these examples help as you decide how to best utilize Deepgram's functionality. Happy building!\n\n";
}
function compiledContent() {
  return `<p>How do you know when someone is finished talking? Before I started working at Deepgram, I hadn\u2019t thought about this question much. When having conversations in person, us humans can use all sorts of contextual cues, body language, and societal norms to figure out when someone has finished their thought and we can jump in with our own opinion. But as we\u2019ve all seen over Zoom during the last few years, figuring out when someone is done talking is a lot harder to do virtually. It\u2019s even harder when the listener isn\u2019t human at all\u2014and is a machine learning model transcribing speech!</p>
<p>Business problems that need speech-to-text often also need an understanding of when a speaker has completed their thought. One common use case for this is building conversational AI bots that need to respond to a user\u2019s queries. The bot needs to be careful both to not to cut the user off, and to respond in a timely enough manner that the conversation feels \u201Creal-time\u201D.</p>
<p>Deepgram\u2019s real-time speech-to-text service provides two main mechanisms that can help build a conversational flow. One is interim results, and the other is endpointing. Together, the two can give you information about when a speaker has finished talking, and when your system should respond.</p>
<p><a href="https://developers.deepgram.com/documentation/features/interim-results/">Interim results</a>, which are disabled by default, are sent back every few seconds. These messages, marked with <code is:raw>is_final=false</code>,  indicate that Deepgram is still gathering more audio and the transcription results may change as additional context is given. Once Deepgram has collected enough audio to make the best possible prediction, it will finalize the prediction and send back a transcript marked with <code is:raw>is_final=true</code>.</p>
<p><a href="https://developers.deepgram.com/documentation/features/endpointing/">Endpointing</a>, which is enabled by default, is an algorithm that detects the end of speech. When endpointing triggers, Deepgram immediately sends back a message. These messages will be marked with <code is:raw>speech_final=true</code> to indicate an endpoint was detected and <code is:raw>is_final=true </code>to indicate the transcription is finalized.</p>
<p>The simplest way to determine when someone is done talking is based on silence. Endpointing can give you almost immediate feedback when silence is detected, which may be useful for applications that prioritize quick processing of results. Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound when Deepgram detects an endpoint.</p>
<p>To run the code, install beepy using <code is:raw>pip install beepy</code>. Then save the following code as <code is:raw>endpointing.py</code>. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:</p>
<p><code is:raw>python endpointing.py  -k 'YOUR_DG_API_KEY'</code></p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> pyaudio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> time</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> argparse</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> beepy</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.paInt16</span></span>
<span class="line"><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">16000</span></span>
<span class="line"><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">callback</span><span style="color: #C9D1D9">(input_data, frame_count, time_info, status_flag):</span></span>
<span class="line"><span style="color: #C9D1D9">    audio_queue.put_nowait(input_data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> (input_data, pyaudio.paContinue)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">run</span><span style="color: #C9D1D9">(key):</span></span>
<span class="line"><span style="color: #C9D1D9">    extra_headers</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token </span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">.format(key)</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> websockets.connect(</span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?endpointing=true&amp;encoding=linear16&amp;sample_rate=16000&amp;channels=1&amp;interim_results=false&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">extra_headers</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> extra_headers) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">microphone</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">            audio </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.PyAudio()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> audio.open(</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">format</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">channels</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">rate</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">input</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">frames_per_buffer</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">stream_callback</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callback</span></span>
<span class="line"><span style="color: #C9D1D9">            )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.start_stream()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> stream.is_active():</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.sleep(</span><span style="color: #79C0FF">0.1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.stop_stream()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sender</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> ws.send(data)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">Exception</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> e:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Error while sending: &#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">str</span><span style="color: #C9D1D9">(e)))</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">raise</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">receiver</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> msg </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">                msg </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(msg)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(msg[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript):</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39; &#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                    transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> msg[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript, </span><span style="color: #FFA657">end</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\r</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> msg[</span><span style="color: #A5D6FF">&#39;speech_final&#39;</span><span style="color: #C9D1D9">]:</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript)</span></span>
<span class="line"><span style="color: #C9D1D9">                        beepy.beep(</span><span style="color: #FFA657">sound</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(microphone()),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(sender(ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(receiver(ws))</span></span>
<span class="line"><span style="color: #C9D1D9">        ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_args</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&quot;&quot;&quot; Parses the command-line arguments.</span></span>
<span class="line"><span style="color: #A5D6FF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    parser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> argparse.ArgumentParser(</span><span style="color: #FFA657">description</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;Submits data to the real-time streaming endpoint.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-k&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--key&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;YOUR_DEEPGRAM_API_KEY (authorization)&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> parser.parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    args </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.get_event_loop().run_until_complete(run(args.key))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>As you may notice when using <code is:raw>endpointing.py</code>, Deepgram will detect that you have finished speaking as soon as possible, meaning that in a conversational flow, this logic can easily cut you off mid-sentence every time you make even a minor pause. Rather than responding immediately, many applications will want to wait for a few seconds after a speaker finishes talking. This can be especially effective in conversational AI, where users may be speaking for long durations and occasionally pause mid-thought\u2014waiting a few seconds to respond may result in a more natural conversational flow. A combination of endpointing and interim results can be used to determine when a desired duration of silence has passed.</p>
<p>Here\u2019s a code example that uses your microphone and the Python package beepy to play a notification sound after the number of seconds defined in a configurable <code is:raw>SILENCE_INTERVAL</code> has passed. (The default is 2.0, but this can be specified when running the script.)</p>
<p>To run the code, install beepy using <code is:raw>pip install beepy</code>. Then save the following code as <code is:raw>silence_interval.py</code>. Turn your volume up so you\u2019ll be able to hear the beep sound, and run the code:</p>
<p><code is:raw>python silence_interval.py  -k 'YOUR_DG_API_KEY' [-s SILENCE_INTERVAL_SECONDS_FLOAT]</code></p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> pyaudio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> beepy</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> shutil</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> argparse</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.paInt16</span></span>
<span class="line"><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">16000</span></span>
<span class="line"><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">terminal_size </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> shutil.get_terminal_size()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">callback</span><span style="color: #C9D1D9">(input_data, frame_count, time_info, status_flag):</span></span>
<span class="line"><span style="color: #C9D1D9">    audio_queue.put_nowait(input_data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> (input_data, pyaudio.paContinue)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">run</span><span style="color: #C9D1D9">(key, silence_interval):</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> websockets.connect(</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?endpointing=true&amp;interim_results=true&amp;encoding=linear16&amp;sample_rate=16000&amp;channels=1&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">extra_headers</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token </span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">.format(key)</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    ) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">microphone</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">            audio </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.PyAudio()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> audio.open(</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">format</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">channels</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">rate</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">input</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">frames_per_buffer</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">stream_callback</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callback</span></span>
<span class="line"><span style="color: #C9D1D9">            )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.start_stream()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> stream.is_active():</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.sleep(</span><span style="color: #79C0FF">0.1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.stop_stream()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sender</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> ws.send(data)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">Exception</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> e:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Error while sending: &#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">str</span><span style="color: #C9D1D9">(e)))</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">raise</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">receiver</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">            last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">            should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">                message </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(message)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                transcript_cursor </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;duration&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #8B949E"># if there are any words in the message</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># handle transcript printing for final messages</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;is_final&#39;</span><span style="color: #C9D1D9">]:</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript):</span></span>
<span class="line"><span style="color: #C9D1D9">                            transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39; &#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript)</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #8B949E"># overwrite the line regardless of length</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #8B949E"># https://stackoverflow.com/a/47170056</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\033</span><span style="color: #A5D6FF">[</span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">A&#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript) </span><span style="color: #FF7B72">//</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(terminal_size.columns) </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">), </span><span style="color: #FFA657">end</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># if the last word in a previous message is silence_interval seconds</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># older than the first word in this message (and if that last word hasn&#39;t already triggered a beep)</span></span>
<span class="line"><span style="color: #C9D1D9">                    current_word_begin </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> current_word_begin </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> silence_interval </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                        should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;end&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># if there were no words in this message, check if the the last word</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># in a previous message is silence_interval or more seconds older</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># than the timestamp at the end of this message (if that last word hasn&#39;t already triggered a beep)</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript_cursor </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> silence_interval </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                        last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">                        should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> should_beep:</span></span>
<span class="line"><span style="color: #C9D1D9">                    beepy.beep(</span><span style="color: #FFA657">sound</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">                    should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># we set/mark last_word_end to 0.0 to indicate that this last word has already triggered a beep</span></span>
<span class="line"><span style="color: #C9D1D9">                    last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">                    transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(microphone()),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(sender(ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(receiver(ws))</span></span>
<span class="line"><span style="color: #C9D1D9">        ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_args</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&quot;&quot;&quot; Parses the command-line arguments.</span></span>
<span class="line"><span style="color: #A5D6FF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    parser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> argparse.ArgumentParser(</span><span style="color: #FFA657">description</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;Submits data to the real-time streaming endpoint.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-k&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--key&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;YOUR_DEEPGRAM_API_KEY (authorization)&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-s&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--silence&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">False</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;A float representing the number of seconds of silence to wait before playing a beep. Defaults to 2.0.&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">default</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">2.0</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> parser.parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    args </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    loop </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.get_event_loop()</span></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.get_event_loop().run_until_complete(run(args.key, </span><span style="color: #79C0FF">float</span><span style="color: #C9D1D9">(args.silence)))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>These two examples should give you an idea of how different conversational flow mechanisms feel, and how they can be incorporated into different types of real-time speech-to-text applications. Both can be found in this <a href="https://github.com/deepgram/conversational-ai-flow">GitHub repo</a>.</p>
<p>We hope these examples help as you decide how to best utilize Deepgram\u2019s functionality. Happy building!</p>`;
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/building-a-conversational-ai-flow-with-deepgram/index.md", "https://blog.deepgram.com/", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>How do you know when someone is finished talking? Before I started working at Deepgram, I hadnt thought about this question much. When having conversations in person, us humans can use all sorts of contextual cues, body language, and societal norms to figure out when someone has finished their thought and we can jump in with our own opinion. But as weve all seen over Zoom during the last few years, figuring out when someone is done talking is a lot harder to do virtually. Its even harder when the listener isnt human at alland is a machine learning model transcribing speech!</p>
<p>Business problems that need speech-to-text often also need an understanding of when a speaker has completed their thought. One common use case for this is building conversational AI bots that need to respond to a users queries. The bot needs to be careful both to not to cut the user off, and to respond in a timely enough manner that the conversation feels real-time.</p>
<p>Deepgrams real-time speech-to-text service provides two main mechanisms that can help build a conversational flow. One is interim results, and the other is endpointing. Together, the two can give you information about when a speaker has finished talking, and when your system should respond.</p>
<p><a href="https://developers.deepgram.com/documentation/features/interim-results/">Interim results</a>, which are disabled by default, are sent back every few seconds. These messages, marked with <code>is_final=false</code>,  indicate that Deepgram is still gathering more audio and the transcription results may change as additional context is given. Once Deepgram has collected enough audio to make the best possible prediction, it will finalize the prediction and send back a transcript marked with <code>is_final=true</code>.</p>
<p><a href="https://developers.deepgram.com/documentation/features/endpointing/">Endpointing</a>, which is enabled by default, is an algorithm that detects the end of speech. When endpointing triggers, Deepgram immediately sends back a message. These messages will be marked with <code>speech_final=true</code> to indicate an endpoint was detected and <code>is_final=true </code>to indicate the transcription is finalized.</p>
<p>The simplest way to determine when someone is done talking is based on silence. Endpointing can give you almost immediate feedback when silence is detected, which may be useful for applications that prioritize quick processing of results. Heres a code example that uses your microphone and the Python package beepy to play a notification sound when Deepgram detects an endpoint.</p>
<p>To run the code, install beepy using <code>pip install beepy</code>. Then save the following code as <code>endpointing.py</code>. Turn your volume up so youll be able to hear the beep sound, and run the code:</p>
<p><code>python endpointing.py  -k 'YOUR_DG_API_KEY'</code></p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> pyaudio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> time</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> argparse</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> beepy</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.paInt16</span></span>
<span class="line"><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">16000</span></span>
<span class="line"><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">callback</span><span style="color: #C9D1D9">(input_data, frame_count, time_info, status_flag):</span></span>
<span class="line"><span style="color: #C9D1D9">    audio_queue.put_nowait(input_data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> (input_data, pyaudio.paContinue)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">run</span><span style="color: #C9D1D9">(key):</span></span>
<span class="line"><span style="color: #C9D1D9">    extra_headers</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token </span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">.format(key)</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> websockets.connect(</span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?endpointing=true&amp;encoding=linear16&amp;sample_rate=16000&amp;channels=1&amp;interim_results=false&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">extra_headers</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> extra_headers) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">microphone</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">            audio </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.PyAudio()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> audio.open(</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">format</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">channels</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">rate</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">input</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">frames_per_buffer</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">stream_callback</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callback</span></span>
<span class="line"><span style="color: #C9D1D9">            )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.start_stream()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> stream.is_active():</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.sleep(</span><span style="color: #79C0FF">0.1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.stop_stream()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sender</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> ws.send(data)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">Exception</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> e:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Error while sending: &#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">str</span><span style="color: #C9D1D9">(e)))</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">raise</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">receiver</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> msg </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">                msg </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(msg)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(msg[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript):</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39; &#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                    transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> msg[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript, </span><span style="color: #FFA657">end</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\r</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> msg[</span><span style="color: #A5D6FF">&#39;speech_final&#39;</span><span style="color: #C9D1D9">]:</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript)</span></span>
<span class="line"><span style="color: #C9D1D9">                        beepy.beep(</span><span style="color: #FFA657">sound</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(microphone()),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(sender(ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(receiver(ws))</span></span>
<span class="line"><span style="color: #C9D1D9">        ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_args</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&quot;&quot;&quot; Parses the command-line arguments.</span></span>
<span class="line"><span style="color: #A5D6FF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    parser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> argparse.ArgumentParser(</span><span style="color: #FFA657">description</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;Submits data to the real-time streaming endpoint.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-k&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--key&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;YOUR_DEEPGRAM_API_KEY (authorization)&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> parser.parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    args </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.get_event_loop().run_until_complete(run(args.key))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>As you may notice when using <code>endpointing.py</code>, Deepgram will detect that you have finished speaking as soon as possible, meaning that in a conversational flow, this logic can easily cut you off mid-sentence every time you make even a minor pause. Rather than responding immediately, many applications will want to wait for a few seconds after a speaker finishes talking. This can be especially effective in conversational AI, where users may be speaking for long durations and occasionally pause mid-thoughtwaiting a few seconds to respond may result in a more natural conversational flow. A combination of endpointing and interim results can be used to determine when a desired duration of silence has passed.</p>
<p>Heres a code example that uses your microphone and the Python package beepy to play a notification sound after the number of seconds defined in a configurable <code>SILENCE_INTERVAL</code> has passed. (The default is 2.0, but this can be specified when running the script.)</p>
<p>To run the code, install beepy using <code>pip install beepy</code>. Then save the following code as <code>silence_interval.py</code>. Turn your volume up so youll be able to hear the beep sound, and run the code:</p>
<p><code>python silence_interval.py  -k 'YOUR_DG_API_KEY' [-s SILENCE_INTERVAL_SECONDS_FLOAT]</code></p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> pyaudio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> asyncio</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> sys</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> websockets</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> json</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> beepy</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> shutil</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> argparse</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.paInt16</span></span>
<span class="line"><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">16000</span></span>
<span class="line"><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">terminal_size </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> shutil.get_terminal_size()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">audio_queue </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.Queue()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">callback</span><span style="color: #C9D1D9">(input_data, frame_count, time_info, status_flag):</span></span>
<span class="line"><span style="color: #C9D1D9">    audio_queue.put_nowait(input_data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> (input_data, pyaudio.paContinue)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">run</span><span style="color: #C9D1D9">(key, silence_interval):</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">with</span><span style="color: #C9D1D9"> websockets.connect(</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?endpointing=true&amp;interim_results=true&amp;encoding=linear16&amp;sample_rate=16000&amp;channels=1&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">extra_headers</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #A5D6FF">&#39;Authorization&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;Token </span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">&#39;</span><span style="color: #C9D1D9">.format(key)</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    ) </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">microphone</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">            audio </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> pyaudio.PyAudio()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> audio.open(</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">format</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">FORMAT</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">channels</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHANNELS</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">rate</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">RATE</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">input</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">frames_per_buffer</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">CHUNK</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">stream_callback</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> callback</span></span>
<span class="line"><span style="color: #C9D1D9">            )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.start_stream()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> stream.is_active():</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.sleep(</span><span style="color: #79C0FF">0.1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            stream.stop_stream()</span></span>
<span class="line"><span style="color: #C9D1D9">            stream.close()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sender</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> audio_queue.get()</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> ws.send(data)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">except</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">Exception</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">as</span><span style="color: #C9D1D9"> e:</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Error while sending: &#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">str</span><span style="color: #C9D1D9">(e)))</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">raise</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">receiver</span><span style="color: #C9D1D9">(ws):</span></span>
<span class="line"><span style="color: #C9D1D9">            transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">            last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">            should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> message </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> ws:</span></span>
<span class="line"><span style="color: #C9D1D9">                message </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> json.loads(message)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                transcript_cursor </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;duration&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #8B949E"># if there are any words in the message</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">]) </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># handle transcript printing for final messages</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;is_final&#39;</span><span style="color: #C9D1D9">]:</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript):</span></span>
<span class="line"><span style="color: #C9D1D9">                            transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39; &#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                        transcript </span><span style="color: #FF7B72">+=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(transcript)</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #8B949E"># overwrite the line regardless of length</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #8B949E"># https://stackoverflow.com/a/47170056</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;</span><span style="color: #79C0FF">\\033</span><span style="color: #A5D6FF">[</span><span style="color: #79C0FF">{}</span><span style="color: #A5D6FF">A&#39;</span><span style="color: #C9D1D9">.format(</span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(transcript) </span><span style="color: #FF7B72">//</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">int</span><span style="color: #C9D1D9">(terminal_size.columns) </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">), </span><span style="color: #FFA657">end</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># if the last word in a previous message is silence_interval seconds</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># older than the first word in this message (and if that last word hasn&#39;t already triggered a beep)</span></span>
<span class="line"><span style="color: #C9D1D9">                    current_word_begin </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;start&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> current_word_begin </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> silence_interval </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                        should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                    last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> message[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;words&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;end&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># if there were no words in this message, check if the the last word</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># in a previous message is silence_interval or more seconds older</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># than the timestamp at the end of this message (if that last word hasn&#39;t already triggered a beep)</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript_cursor </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">&gt;=</span><span style="color: #C9D1D9"> silence_interval </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> last_word_end </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">                        last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">                        should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">True</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> should_beep:</span></span>
<span class="line"><span style="color: #C9D1D9">                    beepy.beep(</span><span style="color: #FFA657">sound</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">                    should_beep </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">False</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #8B949E"># we set/mark last_word_end to 0.0 to indicate that this last word has already triggered a beep</span></span>
<span class="line"><span style="color: #C9D1D9">                    last_word_end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0.0</span></span>
<span class="line"><span style="color: #C9D1D9">                    transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> asyncio.wait([</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(microphone()),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(sender(ws)),</span></span>
<span class="line"><span style="color: #C9D1D9">            asyncio.ensure_future(receiver(ws))</span></span>
<span class="line"><span style="color: #C9D1D9">        ])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_args</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&quot;&quot;&quot; Parses the command-line arguments.</span></span>
<span class="line"><span style="color: #A5D6FF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    parser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> argparse.ArgumentParser(</span><span style="color: #FFA657">description</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;Submits data to the real-time streaming endpoint.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-k&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--key&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">True</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;YOUR_DEEPGRAM_API_KEY (authorization)&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    parser.add_argument(</span><span style="color: #A5D6FF">&#39;-s&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;--silence&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">required</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">False</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">help</span><span style="color: #FF7B72">=</span><span style="color: #A5D6FF">&#39;A float representing the number of seconds of silence to wait before playing a beep. Defaults to 2.0.&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">default</span><span style="color: #FF7B72">=</span><span style="color: #79C0FF">2.0</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> parser.parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">    args </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> parse_args()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    loop </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> asyncio.get_event_loop()</span></span>
<span class="line"><span style="color: #C9D1D9">    asyncio.get_event_loop().run_until_complete(run(args.key, </span><span style="color: #79C0FF">float</span><span style="color: #C9D1D9">(args.silence)))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">__name__</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;__main__&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    sys.exit(main() </span><span style="color: #FF7B72">or</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>These two examples should give you an idea of how different conversational flow mechanisms feel, and how they can be incorporated into different types of real-time speech-to-text applications. Both can be found in this <a href="https://github.com/deepgram/conversational-ai-flow">GitHub repo</a>.</p>
<p>We hope these examples help as you decide how to best utilize Deepgrams functionality. Happy building!</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/building-a-conversational-ai-flow-with-deepgram/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
